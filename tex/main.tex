
% Original author: Al Sweigart, http://inventwithpython.com/
% License: BY-NC-SA, http://creativecommons.org/licenses/by-nc-sa/3.0/us/
% Translation: GDR!, http://gdr.geekhood.net/

\documentclass{book}

\renewcommand{\rmdefault}{FreeSerif}
%\renewcommand{\sfdefault}{FreeSerif}
%\renewcommand{\ttdefault}{Courier}
% \setttfont{AndaleMono}

\usepackage{ucs}
\usepackage[pdftex,plainpages=false,pdfpagelabels,pdfstartpage=1,pdfstartview=FitH]{}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[polish]{babel}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{listings}
% \usepackage{listingsutf8}
\usepackage{color}
\usepackage{framed}

\onehalfspacing

% According to polish grammar rules, you have to put dots after numerals in chapter, section, subsection, etc. headers.
\renewcommand\thechapter{\arabic{chapter}.}
\renewcommand\thesection{\arabic{chapter}.\arabic{section}.}
\renewcommand\thesubsection{\arabic{chapter}.\arabic{section}.\arabic{subsection}.}
\renewcommand\thesubsubsection{\arabic{chapter}.\arabic{section}.\arabic{subsection}.%
                                                           \arabic{subsubsection}.}
% It's customary (depends on publisher) to indent first paragraph in sections and chapters:
\usepackage{indentfirst}

% Fixes a bug in lstlisting
\lstset{extendedchars=\false,inputencoding=utf8x,showspaces=false}
\lstset{literate={ą}{{\k{a}}}1 {ć}{{\'c}}1 {ł}{{\l{}}}1 {ń}{{\'n}}1 {ę}{{\k{e}}}1 {ś}{{\'s}}1 {ż}{{\.z}}1 {ó}{{\'o}}1 {ź}{{\'z}}1 {Ą}{{\k{A}}}1 {Ć}{{\'C}}1 {Ł}{{\L{}}}1 {Ń}{{\'N}}1 {Ę}{{\k{E}}}1 {Ś}{{\'S}}1 {Ż}{{\.Z}}1 {Ó}{{\'O}}1 {Ź}{{\'Z}}1 }

% Fixed-width font for listings
\lstset{basicstyle=\ttfamily}
\lstset{breaklines=true}
\lstset{linewidth=1.3\linewidth}


% Numbered listing
\definecolor{codebg}{gray}{0.9}
\newcommand{\bnl}[1]{\lstset{language=Python,numbers=left,backgroundcolor=\color{codebg},frame=single,#1}}

% Non-numbered listing
\newcommand{\bl}[1]{\lstset{language=Python,numbers=none,backgroundcolor=\color{codebg},frame=single,#1}}

% Pseudo-listing definiton
%TODO fixed-width font
\makeatletter\newenvironment{pseudolisting}{%
\begin{lrbox}{\@tempboxa}\begin{minipage}{\columnwidth}\begin{flushleft}}{\end{flushleft}\end{minipage}\end{lrbox}%
\colorbox{codebg}{\usebox{\@tempboxa}}
}\makeatother

% Image macro
\newcommand{\img}[3]{
\begin{figure}
\centerline{
	\includegraphics[width=#3]{#1.png}
}
\caption{#2}
\label{#1}
\end{figure}
}

% Topics covered 
\definecolor{topicscoveredbg}{gray}{0.9}
          
% Gray bg definition
\makeatletter\newenvironment{graybox}{%
\begin{lrbox}{\@tempboxa}\begin{minipage}{\columnwidth}}{\end{minipage}\end{lrbox}%
\colorbox{topicscoveredbg}{\usebox{\@tempboxa}}
}\makeatother

\newcommand{\btopicscovered}{
	\begin{graybox}
	\begin{itemize}
}
\newcommand{\etopicscovered}{
	\end{itemize}
	\end{graybox}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\chapter{Instalacja Pythona}

Ściągnij Pythona 3.1 ze strony Python.org.

W razie czego - http://inventwithpython.com/chapter1.html bo ten rozdział nie jest gotowy.

\chapter{Shell interaktywny}
\btopicscovered
	\item Liczby całkowite i~zmiennoprzecinkowe
	\item Wyrażenia
	\item Wartości
	\item Operatory
	\item Ewaluacja wyrażeń
	\item Przechowywanie wartości w~zmiennych
	\item Nadpisywanie zmiennych
\etopicscovered

Zanim rozpoczniemy pisać gry komputerowe, powinniśmy poznać kilka pojęć związanych z~programowaniem. Chodzi o~wartości, operatory, wyrażenia i~zmienne. Nie zaczniemy jeszcze w~tym rozdziale pisać programów, ale poznanie tych pojęć i~różnych nazw bardzo uprości dalszą naukę. To dlatego, że większa część programowania to tylko kilka prostych pomysłów połączonych w~całość i~tworzących duże programy.

Zacznijmy od nauczenia się jak używać interaktywnego shella Pythona.

\section{Trochę prostej matematyki}

% Tego akapitu nie było w oryginale
Python posiada interaktywnego shella o~nazwie IDLE.~Interaktywność oznacza, że reaguje on na~wszystkie twoje polecenia zaraz po ich wpisaniu (nieinterkatywny tryb pracy to taki w~którym wpierw wpisujesz wszystkie polecenia do~pliku, a~dopiero potem są one wykonywane po kolei). Shell\footnote{Shell jest przez niektórych nazywany również ,,powłoką''. Zabawne, prawda?} to miejsce gdzie wpisujesz polecenia - zgłasza się znakiem \lstinline{>>>} nazywanym znakiem zachęty (lub promptem).

Żeby otworzyć IDLE na~Windowsie, kliknij na~Start, Programy, Python 3.1 a~potem IDLE (Python GUI). Zaczniemy od kilku prostych obliczeń w~Pythonie. Interaktywny shell może działać jak kalkulator. Wpisz w~okno shella 2+2 i~wciśnij Enter na~klawiaturze (na~niektórych klawiaturach ten klawisz to Return). Jak widzisz na~rysunku~\ref{idle-dwaplusdwa}, komputer powinien odpowiedzieć liczbą 4, sumą 2+2.

\img{idle-dwaplusdwa}{Wpisz w~okno shella 2+2}{7 cm}

Jak widzisz, możemy używać shella Pythona jako kalkulatora. To co zrobiłeś nie jest jeszcze programem, ponieważ dopiero uczymy się podstaw. Znak + każe komputerowi dodać liczby 2 i~2. Aby odjąć liczby, użyj znaku -, żeby je pomnożyć użyj gwiazdki (*), i~tak dalej:

\begin{table}[here]
\caption{Różne operatory matematyczne w~Pythonie}
\centerline{
\begin{tabular}{| c | c | }
\hline
2+2 & dodawanie\\
\hline
2-2 & odejmowanie\\
\hline
2*2 & mnożenie\\
\hline
2/2 & dzielenie\\
\hline
\end{tabular}
}
\label{math-operators}
\end{table}

Znaki +, -, * i~/ kiedy używa się ich w~ten sposób, są nazywane {\bf operatorami} ponieważ mówią komputerowi żeby wykonał jakąś operację na~liczbach które je otaczają.

\subsection{Liczby całkowite i~zmiennoprzecinkowe}

W programowaniu (a~także matematyce), liczby takie jak 4, 0 czy 99 nazywane są {\bf całkowitymi}. Liczby z~ułamkami bądź kropką dziesiętną\footnote{W matematyce do~oddzielania części całkowitej od ułamkowej używa się przecinka, w~programowaniu - zazwyczaj jest to kropka.} (jak 3.5, 42.1, 5.0) nie są całkowite. W~Pythonie, liczba 5 jest całkowita, ale jeśli zapiszemy ją jako 5.0 - już nie. Liczby z~kropką dziesiętną nazywają się {\bf liczbami zmiennoprzecinkowymi}. W~matematyce, 5.0 ciągle pozostaje liczbą całkowitą i~ma tą samą wartość co 5, ale komputer traktuje liczby całkowite i~zmiennoprzecinkowe inaczej.

\subsection{Wyrażenia}

Spróbuj wpisać któreś z~tych działań do~shella, wciskając po każdym z~nich Enter.

\begin{lstlisting}
2+2+2+2+2
8*6
10-5+6
2  +       2      
\end{lstlisting}

\img{idle-wyrazenia}{Okno IDLE po wykonaniu wyrażeń}{7 cm}

Te działania matematyczne nazywane są wyrażeniami. Komputery potrafią rozwiązać miliony tego typu zadań w~ciągu sekundy. Wyrażenia są złożone z~{\bf wartości} (liczb) połączonych {\bf operatorami} (symbolami matematycznymi). Dowiedzmy się czym dokładnie są wartości i~operatory.

\img{idle-wyroperwart}{Wyrażenie składa się z~wartośći i~operatorów}{3 cm}

W ostatnim wyrażeniu w~przykładach wyżej mogłeś się przekonać, że można użyć dowolnej ilości spacji (odstępów) pomiędzy liczbami oraz operatorami. Pamiętaj jednak, żeby zawsze zaczynać pisać od samego początku linii, nie wstawiając dodatkowych odstępów przed pierwszą liczbą.

Liczba jest rodzajem wartości. Liczba całkowita jest rodzajem liczby. Ale, chociaż liczby całkowite są liczbami, nie wszystkie liczby są liczbami całkowitymi (na~przykład, ułamki i~liczby z~kropką dziesiętną jak 2.5 są liczbami ale nie są całkowite).

To podobnie jak kot jest rodzajem zwierzęcia domowego, ale nie wszystkie zwierzęta domowe są kotami. Są przecież ludzie którzy mają psy lub kraby. 

{\bf Wyrażenie} składa się z~wartości (na~przykład liczb całkowitych takich jak 8 czy 6) połączonych operatorem (takim jak znak mnożenia *). Pojedyncza wartość bez operatorów też traktowana jest jak wyrażenie.

W następnym rozdziale nauczymy się jak pracować z~wyrażeniami tekstowymi. Python nie jest ograniczony do~liczb. Umie wiele więcej niż zwykły kalkulator.

\section{Ewaluacja wyrażeń}

Kiedy komputer rozwiązuje wyrażenie 10+5 i~otrzymuje wartość 15, mówimy że {\bf ewaluuje} (oblicza) wyrażenie. Ewaluacja wyrażenia zamienia je w~pojedynczą wartość, podobnie jak rozwiązanie zadania matematycznego zamienia je w~pojedynczą liczbę: rozwiązanie.

Wyrażenia 10+5 oraz 10+3+2 mają tą samą wartość, ponieważ oba są ewaluowane do~15. Nawet pojedyncze wartości są wyrażeniami: wyrażenie 15 ewaluuje się do~wartośći 15.

Jeśli jednak wpiszesz w~interaktywnym shellu tylko 5+, dostaniesz wiadomość o~błędzie.
\lstset{language=python}
\begin{lstlisting}{}
>>> 5 +
SyntaxError: invalid syntax
\end{lstlisting}

Ten błąd zdarzył się ponieważ 5+ nie jest wyrażeniem. Wyrażenia to wartości połączone operatorami, a~operator + zawsze spodziewa się dwóch wartości. My podaliśmy mu tylko jedną. Dlatego właśnie pojawił się komunikat o~błędzie. Błąd składni (Syntax Error) oznacza, że komputer nie rozumie instrukcji którą mu podałeś ponieważ wpisałeś ją nieprawidłowo. Python zawsze wyświetli błąd jeśli wprowadzisz instrukcję której nie zrozumie.

To może nie wydawać się w~tej chwili ważne, ale duża część programowania polega nie tylko na~mówieniu komputerowi co ma zrobić, ale też na~posiadaniu wiedzy jak dokładnie powiedzieć komputerowi żeby to zrobił.

\subsection{Wyrażenia wewnątrz innych wyrażeń}

% Różni się od oryginału - krótsze zdania.
Wyrażenia mogą również zawierać inne wyrażenia. Na przykład, wyrażenie 2+5+8 zawiera dwa operatory +, co powoduje że składa się z~dwóch mniejszych wyrażeń.~Python najpierw oblicza 2+5, wynikiem jest 7. Następnie oblicza 7+8 i~wynikiem jest 15.

Pomyśl o~wyrażeniu jak o~stosie cukierków: jeśli położysz dwa stosy cukierków jeden na~drugim, będziesz miał znów stos cukierków (tyle, że większy). Duży stos cukierków może być złożony z~mniejszych stosów wysypanych jeden na~drugi. Wyrażenia mogą być składane razem i~w~ten sam sposób tworzyć większe wyrażenia. Ale niezależnie od tego jak duże jest wyrażenie, zawsze będzie się ewaluowało do~pojedynczej odpowiedzi, podobnie jak 2+5+8 ewaluuje się do~15.

\section{Przechowywanie wartości w~zmiennych}

Kiedy piszemy program, często chcielibyśmy zachować wyniki ewaluacji naszych wyrażeń żeby móc ich używać w~dalszej części programu. Możemy przechowywać wartości w~{\bf zmiennych}.

Pomyśl że zmienna to pudełko które może przechowywać wartość. Możesz przechować wartość w~zmiennej używając znaku = (nazywanego {\bf operatorem przypisania}). na~przykład, żeby przechować wartość 15 w~zmiennej o~nazwie ,,liczba'', wpisz w~shellu liczba=15:

\lstset{language=python}
\begin{lstlisting}{}
>>> liczba = 15
>>>
\end{lstlisting}

\img{idle-zmienna}{Zmienne są jak pudełka które przechowują wartości}{4 cm}

Zmienna którą stworzyłeś jest jak pudełko z~wartością 15 w~środku (jak na~rysunku \ref{idle-zmienna}). Nazwa zmiennej (,,liczba'') jest jak etykieta na~pudełku (żeby można było rozróżnić jedną zmienną od drugiej), a~wartość przechowywana przez zmienną jest jak karteczka w~środku pudełka.

Kiewy wciśniesz Enter, nie zobaczysz żadnej odpowiedzi od Pythona. O~ile nie zobaczysz wiadomości o~błędzie, możesz założyć że instrukcja została wykonana poprawnie. Pojawi się następny znak zachęty \lstinline{>>>} żebyś mógł wpisać kolejną instrukcję.

Ta instrukcja (nazywana {\bf instrukcją przypisania}) tworzy zmienną ,,liczba'' i~przechowuje w~niej wartość 15. W~przeciwieństwie do~wyrażeń, {\bf instrukcje} nie są ewaluowane do~żadnej wartości. Dlatego właśnie shell nie wyświetlił żadnej wartości w~odpowiedzi.

Może nie być łatwo zapamiętać które polecenia są wyrażeniami, a~które instrukcjami. Po prostu pamiętaj, że jeśli polecenie ewaluuje się do~jakiejś wartości, jest wyrażeniem. Jeśli nie, jest instrukcją.

Instrukcja przypisania jest zapisana w~następujący sposób: nazwa zmiennej, później znak = oraz wyrażenie. Wartość, do~której ewaluuje się to wyrażenie, jest przechowywana w~zmiennej. Wartość 15 sama w~sobie jest wyrażeniem. Wyrażenia złożone z~pojedynczej wartości są proste do~ewaluacji. Takie wyrażenia ewaluują się po prostu do~tej samej wartości. Na przykład, wyrażenie 15 ewaluuje się do~wartości 15.

Pemiętaj, zmienne przechowują wartości, nie wyrażenia. Na przykład, jeśli mielibyśmy wyrażenie liczba=10+5, to wyrażenie 10+5 zostałoby wpierw obliczone, a~następnie wynik (15) zostałby przechowany w~zmiennej ,,liczba''.

Kiedy zapisujesz wartość do~zmiennej po raz pierwszy używając instrukcji przypisania, Python stworzy tę zmienną. Za każdym następnym razem, operator przypisania zamieni wartość zapamiętaną w~tej zmiennej.

Sprawdźmy czy zmienna stworzyła się poprawnie. Jeśli wpiszemy w~shellu tylko ,,liczba'', powinniśmy zobaczyć jaka wartość jest przechowywana w~zmiennej o~tej nazwie:

\begin{lstlisting}
>>> liczba = 15
>>> liczba
15
>>> 
\end{lstlisting}

W tej chwili wyrażenie ,,liczba'' jest ewaluowane do~wartości przechowywanej przez zmienną ,,liczba'', czyli 15.

Wiedząc to wszystko, możemy zrobić ciekawą rzecz. Jeśli teraz wpiszemy do~shella ,,liczba + 5", otrzymamy wartość 20:

\begin{lstlisting}
>>> liczba+5
20
>>> 
\end{lstlisting}

Może się to wydawać dziwne, ale ma sens jeśli przypomnimy sobie że ustawiliśmy wartość ,,liczba'' na~15. Z~tego powodu, napisanie ,,liczba + 5'' jest zupełnie jak napisanie ,,15 + 5".

Jeśli spróbujesz użyć zmiennej zanim została stworzona, Python zwróci ci komunikat błędu ponieważ taka zmienna jeszcze nie istnieje. Zdarzy się to również jeśli zrobisz literówkę w~nazwie istniejącej zmiennej:


\begin{lstlisting}
>>> lcibza

Traceback (most recent call last):
  File "<pyshell#10>", line 1, in <module>
      lcibza
NameError: name 'lcibza' is not defined
>>> 
\end{lstlisting}

Możemy zmienić wartość przechowywaną w~zmiennej wprowadzając jeszcze jedną instrukcję przypisania. Spróbuj na~przykład tego:

\begin{lstlisting}
>>> liczba=15
>>> liczba + 5
20
>>> liczba = 3
>>> liczba + 5
8
>>> 
\end{lstlisting}

Za pierwszym razem kiedy wpisałeś ,,liczba + 5", wartością wyrażenia było 20, ponieważ zmienna ,,liczba'' przechowywała wartość 15. Ale kiedy wpisałeś ,,liczba = 3", wartość 15 została zamieniona (nadpisana) wartością 3. Z~tego powodu, jeśli wpisałeś później ,,liczba + 5", wartością wyrażenia było 8.

Aby dowiedzieć się jaką wartość przechowuje zmienna, wpisz jej nazwę w~shellu.

Ponieważ zmienna jest tylko nazwą dla wartości, możemy robić też takie działania jak poniżej:

\begin{lstlisting}
>>> liczba = 15
>>> liczba + liczba
30
>>> liczba - liczba
0
>>> 
\end{lstlisting}

Kiedy zmienna ,,liczba'' przechowuje wartość 15, wpisanie ,,liczba + liczba'' odpowiada wpisaniu ,,15 + 15". Wartością takiego wyrażenia jest 30. Z~kolei wyrażenie ,,liczba - liczba'' ma wartość 0 ponieważ odpowiada wyrażeniu ,,15 - 15". Wyrażenia powyżej używają zmiennej ,,liczba'' dwa razy. Możesz używać zmiennych w~wyrażeniach ile tylko razy chcesz. Pamiętaj że Python będzie ewaluował nazwę zmiennej do~wartości w~niej przechowywanej za każdym razem kiedy zmienna będzie użyta.

Możemy nawet użyć wartości zmiennej ,,liczba'' aby przypisać zmiennej ,,liczba'' nową wartość!

\begin{lstlisting}
>>> liczba = 15
>>> liczba = liczba + 5
>>> liczba
20
\end{lstlisting}

Wyrażenie przypisania ,,liczba = liczba + 5'' jest jak powiedzenie ,,nowa wartość zmiennej liczba będzie równa obecnej wartości plus pięć''. Pamiętaj że do~zmiennej po lewej stronie znaku = będzie przypisana wartość do~której ewaluuje się wyrażenie po prawej stronie znaku. Możemy też zwiększać wartość zmiennej liczba kilka razy:

\begin{lstlisting}
>>> liczba = 15
>>> liczba = liczba + 5
>>> liczba = liczba + 5
>>> liczba = liczba + 5
>>> liczba
30
\end{lstlisting}

\section{Używanie więcej niż jednej zmiennej}

Kiedy piszesz program, nie jesteś ograniczony do~używania jednej zmiennej. Często będziesz potrzebował używać wielu.

Na przykład, przypiszmy różne wartości do~dwóch zmiennych o~nazwach ,,foo'' oraz ,,bar'':

\begin{lstlisting}
>>> foo = 10
>>> bar = 15
\end{lstlisting}

Teraz zmienna foo ma wartość 10, a~zmienna bar - 15.

\img{idle-zmienne}{Zmienne ,,foo'' i~,,bar'' przechowują różne wartości}{10 cm}

Spróbujmy zmienić teraz zmienną ,,liczba''. Wpisz ,,liczba = foo + bar'' do~okna shella i~sprawdź jaka będzie nowa wartość zmiennej ,,liczba''. Czy potrafisz zgadnąć jaka?

\begin{lstlisting}
>>> foo = 10
>>> bar = 15
>>> liczba = foo + bar
>>> liczba
25
\end{lstlisting}

Wartość zmiennej ,,liczba'' wynosi teraz 25, ponieważ dodając ,,foo'' i~,,bar'', dodajemy wartości przechowywane w~,,foo'' (10) i~,,bar'' (15).

\subsection{Nadpisywanie zmiennych}

Zmiana wartości przechowywanej w~zmiennej jest prosta. Po prostu przypisz jej nową wartość. Sprawdź, co się stanie po wprowadzeniu następującego kodu do~shella:

\begin{lstlisting}
>>> foo = 42
>>> foo
42
>>> foo = 'Czesc'
>>> foo
'Czesc'
\end{lstlisting}

Na początku, zmienna ,,foo'' przechowywała liczbę 42. Dlatego właśnie za pierwszym razem po wpisaniu ,,foo'' komputer zwrócił ,,42". Ale po wykonaniu ,,spam='Czesc'", wartość 42 została usunięta ze zmiennej i~zapomniana w~momencie w którym tekst ,,Czesc'' został w~niej zapamiętany.

Zmiana wartości zmiennej na~nową wartość nazywana jest {\bf nadpisywaniem}. Ważne jest, żeby wiedzieć, że stara wartość zostanie na~zawsze zapomniana. Jeśli chcesz ją zapamiętać żeby użyć jej później, możesz zapamiętać ją w~innej zmiennej przed zmianą wartości.

\begin{lstlisting}
>>> foo = 42
>>> foo
42
>>> stareFoo = foo
>>> foo = 'Czesc'
>>> foo
'Czesc'
>>> stareFoo
42
\end{lstlisting}

W powyższym przykładzie, przed nadpisaniem wartości zmiennej ,,foo'', skopiowaliśmy jej wartość do~zmiennej o~nazwie ,,stareFoo''. W~tym momencie, zarówno ,,foo'' jak i~,,stareFoo'' mają wartość 42. W~następnej linii, w~zmiennej ,,foo'' zapamiętany zostaje tekst ,,Czesc'', ale zmienna stareFoo pozostaje nietknięta.

\section{Podsumowanie}

W tym rozdziale nauczyłeś się podstaw pisania instrukcji Pythona. Musisz mówić Pythonowi bardzo dokładnie i~ściśle co ma zrobić, ponieważ komputery nie potrafią myśleć i~rozumieją tylko bardzo proste rozkazy. Nauczyłeś się, że Python potrafi ewaluować wyrażenia (to znaczy, zamienić całe wyrażenie na~pojedynczą wartość), i~że wyrażenia to wartości (takie jak 2 czy 5) połączone operatorami (takimi jak + lub -). Dowiedziałeś się także, że możesz przechowywać wartości w~zmiennych, żeby twój program je zapamiętał, a~żebyś ty mógł użyć ich później.

W następnym rozdziale poznasz jeszcze kilka podstawowych pojęć, a~później napiszesz swój pierwszy program!

\chapter{Tekst}

\btopicscovered
	\item Wykonanie programu
	\item Stringi
	\item Łączenie stringów
	\item Typy danych (takie jak stringi czy liczby całkowite)
	\item Używanie IDLE do~pisania kodu źródłowego
	\item Zapisywanie i~uruchamianie programów w~IDLE
	\item Funkcja print()
	\item Funkcja input()
	\item Komentarze
	\item Wielkie litery w~nazwach zmiennych
	\item Rozróżnianie wielkości liter
\etopicscovered

Wystarczy już liczb i~matematyki. Python jest znacznie więcej niż tylko kalkulatorem. Sprawdźmy teraz, co potrafi robić z~tekstem. W~tym rozdziale nauczymy się jak przechowywać tekst w~zmiennych, łączyć teksty i~wyświetlać je na~ekranie. Wiele z~naszych programów będzie używało tekstu do~wyświetlania gier na~ekranie gracza, a~gracz będzie wprowadzał do nich tekst za pomocą klawiatury. Napiszemy też pierwszy program, który pozdrowi użytkownika tekstem ,,Witaj, świecie!'' i~spyta go o~imię.

\section{Stringi}

W Pythonie używamy małych fragmentów tekstu nazywanych {\bf stringami}\footnote{Niektórzy nazywają je także łańcuchami tekstowymi}. Możemy przechowywać stringi w~zmiennych dokładnie tak, jak przechowywaliśmy liczby. Kiedy wpisujemy stringi, otaczamy je dwoma apostrofami (') w~ten sposób:

\begin{lstlisting}
>>> foo = 'czesc'
>>>
\end{lstlisting}

Apostrofów używa się tylko po to, żeby komputer wiedział gdzie tekst się zaczyna i~kończy. Nie są one częścią tekstu.

% This was not in the original
{\bf Uwaga} - na klawiaturze są dwa znaki apostrofa, jeden w lewym górnym rogu (backtick), drugi - bliżej Entera, na prawo od klawisza ; (właściwy apostrof). My używamy tego drugiego (bliżej Entera).

Jeśli teraz wpiszesz w~shellu \lstinline{foo}, powinienneś zobaczyć zawartość zmiennej \lstinline{foo} (string 'czesc'). 


\begin{lstlisting}
>>> foo = 'czesc'
>>> foo
'czesc'
>>>
\end{lstlisting}

Stało się tak dlatego, że Python ewaluuje zmienną \lstinline{foo} do~wartości przez nią przechowywanej (w~tym wypadku, do~tekstu 'czesc').

Stringi mogą zawierać prawie każdy znak na~klawiaturze (nie mogą zawierać apostrofów bez wcześniejszego ich wyescapowania. Escapowanie będzie opisane dalej). Poniżej są przykłady prawidłowych stringów:

\begin{lstlisting}
'czesc'
'Jak się masz?'
'ALAMAKOTA'
'7 jabłek, 14 pomarańczy, 3 cytryny i czosnek'
'Słuchaj, jeszcze chwila i otworzę wytwórnię salami.'
'Dawno, dawno temu w odległej galaktyce...'
'O*&#wY%*&OCfsdYO*&gfC%YO*&%3yc8r2'
\end{lstlisting}

Podobnie jak w~poprzednim rozdziale robiliśmy to z~liczbami, stringi również możemy łączyć operatorami tworząc wyrażenia.

\section{Konkatenacja stringów}

Możesz ,,dokleić" jednego stringa na~koniec drugiego używając operatora +. Operacja taka nazywa się konkatenacją (łączeniem) stringów. Spróbuj wpisać w~shellu \lstinline{'Witaj' + 'Świecie!'}

\begin{lstlisting}
>>> 'Witaj' + 'Swiecie!'
'WitajSwiecie!'
>>>
\end{lstlisting}

Żeby oddzielić słowa, dopisz spację po stringu 'Witaj' przed zamykającym apostrofem, w~ten sposób:

\begin{lstlisting}
>>> 'Witaj ' + 'Swiecie!'
'Witaj Swiecie!'
>>> 
\end{lstlisting}

Operator + działa w~inny sposób dla stringów i~dla liczb, ponieważ są one różnymi {\bf typami danych}. Każda wartość posiada typ (jest jakiegoś typu). Wartość 'Cześć' jest typu ,,string''. Wartość 5 jest typu ,,liczba całkowita''. Typ wartości mówi nam (i~komputerowi), jaki rodzaj danych ona przechowuje. 

\section{Pisanie programów w~edytorze IDLE}

Do teraz pisaliśmy instrukcje jedna po drugiej w~interaktywnym shellu. Ale kiedy piszemy program, wpierw wpisujemy kilka instrukcji, a~następnie uruchamiamy je wszystkie razem. Napiszmy więc pierwszy program!

Program, który pokazywał okno interaktywnego shella w~którym działaliśmy do~tej pory nazywał się IDLE (Interactive DeveLopment Environment - Interaktywne Środowisko Programistyczne). IDLE ma także inną funkcję - edytor plików.

Kliknij na~menu File (Plik) na~górze okna, wybierz New Window (Nowe Okno). Pojawi sie nowe puste okno w~którym będziesz mógł pisać program. To okno to {\bf edytor plików}.

\img{strings-fileeditor}{Okno edytora plików}{7 cm}

\section{Witaj Świecie!}

Istnieje w programowaniu tradycja polegająca na tym, że kiedy uczysz się nowego języka programowania, piszesz program wyświetlający na ekranie tekst ,,Witaj, Świecie!'' (,,Hello, World!"). Stwórzmy więc własny program Hello World w Pythonie!

% The following 2 paragraphs in original order make little sense
Wprowadź tekst poniżej do~nowego okna edytora plików. Nazywamy ten tekst kodem źródłowym programu ponieważ zawiera instrukcje które Python będzie wykonywał żeby wiedzieć dokładnie jak program powinien się zachować.

Kiedy wprowadzasz program, nie wpisuj liczb po lewej stronie kodu. Są tam jedynie po to, żeby omawiając kod można było się odnieść do~konkretnej linii po numerze. Jeśli spojrzysz na~prawy dolny róg edytora, zobaczysz numer linii w~której kursor znajduje się w~danym momencie.

\img{strings-nrlinii}{Prawy dolny róg okna edytora powie ci w~której linii znajduje się kursor. Tutaj znajduje się w~linii 12.}{3 cm}


{\bf Uwaga!} Ten program działa tylko z~Pythonem w~wersji 3, więc jeśli masz zainstalowanego Pythona 2.6 lub jakąkowiek inną wersję z~serii 2.x, program nie będzie działał. Świadczy o~tym błąd: \lstinline{NameError: name is not defined}.

\bnl{caption=hello.py}
\lstinputlisting{python/hello.py}
% TODO URL

Okno programu IDLE będzie pokazywało różne rodzaje instrukcji w~różnych kolorach. Kiedy skończysz przepisywać kod, okno powinno wyglądać tak, jak na~rysunku \ref{strings-idle}.

\img{strings-idle}{Okno edytora plików powinno po wprowadzeniu kodu  wyglądać w~ten sposób}{10 cm}

\subsection{Zapisywanie programu}

\img{strings-saveas}{Zapisywanie programu}{7 cm}

Po przepisaniu kodu źródłowego programu, zapisz go żebyś nie musiał go wpisywać od nowa za każdym razem kiedy startujesz IDLE.~Aby to zrobić, w~menu File (Plik) wybierz opcję Save As (Zapisz Jako). Powinno pokazać się okno wyboru pliku. Wpisz jako nazwę pliku ,,hello.py'' (jak na~rysunku \ref{strings-saveas}) i~wciśnij Save (Zapisz).

Kiedy wpisujesz program, powinenneś raz na~jakiś czas zapisywać jego kod. W~ten sposób, jeśli komputer przypadkowo się wyłączy lub niechcąco wyjdziesz z~IDLE, zgubi się tylko część tekstu. Wciskając Ctrl-S, szybko zapiszesz plik bez użycia myszki.

%TODO mention about python2?

\subsection{Otwieranie zapisanych programów}

Aby wczytać zapisany program, wybierz w~menu File (Plik) opcję Open (Otwórz). W~oknie które się pojawi, wybierz ,,hello.py'' i~wciśnij przycisk Open (Otwórz). Program hello.py który zapisałeś otworzy się w~oknie edytora plików.

A teraz - czas na~uruchomienie programu! Z~menu Run (Uruchom) wybierz opcję Run Module (Uruchom Moduł) lub po prostu wciśnij na~klawiaturze klawisz F5. Twój program powinien uruchomić się w~oknie shella (tym, które pokazało się kiedy uruchomiłeś IDLE). Pamiętaj, musisz wcisnąć F5 w~oknie edytora plików (tam, gdzie przepisałeś kod) - nie w~oknie interaktywnego shella.

\img{strings-hello}{Tak powinno wyglądać okno shella po uruchomieniu programu ,,Hello World''}{7 cm}

Kiedy program spyta cię o~imię, wpisz je a~potem wciśnij Enter jak na~rysunku \ref{strings-hello}.

\section{Jak działa program Witaj Świecie}

W jaki sposób nasz program działa? Każda z~linii którą wprowadziliśmy jest instrukcją którą Python tłumaczy tak, żeby komputer potrafił ją wykonać. Program komputerowy jest jak przepis kucharski. Najpierw wykonaj pierwszy krok, potem drugi i~tak dalej, aż dotrzesz do~końca. Każda instrukcja jest wykonywana jedna po drugiej, zaczynając od góry programu i~idąc dalej instrukcja po instrukcji. Po tym jak program wykona instrukcje z~pierwszej linii, zaczyna wykonywać drugą linię, potem trzecią i~tak dalej.

Przechodzenie programu od instrukcji do~instrukcji nazywamy {\bf przepływem wykonania} lub po prostu {\bf wykonywaniem}.

Spojrzmy teraz na~program linia po linii żeby zobaczyć co robi. Zacznijmy od pierwszej.

\subsection{Komentarze}
\bnl{caption=,name=hello}
\lstinputlisting[firstline=1,lastline=1]{python/hello.py}

Ta linia nazywana jest {\bf komentarzem}. Każdy tekst za znakiem \lstinline{#} (znak ten nazywany jest {\bf hashem}\footnote{czyt. hasz}) jest komentarzem. Komentarze nie są przeznaczone dla komputera, ale dla ciebie - programisty. Komputer je ignoruje. Używane są do~przypominania ci co program robi, lub do~mówienia innym ludziom jak działa twój kod.

Programiści zazwyczaj żeby nadać programowi tytuł dodają komentarz na~samym początku kodu. Program IDLE wyświetla komentarze na~czerwono żeby bardziej się wyróżniały.

\subsection{Funkcje}

{\bf Funkcja} jest rodzajem mini-programu wewnątrz twojego programu. Zawiera linie kodu który jest wykonywany od góry do~dołu. Python dostarcza kilku wbudowanych funkcji, których możemy używać. Najlepszą rzeczą w~funkcjach jest to, że wystarczy że wiemy co dana funkcja robi, nie jak to robi. Jedyne co musisz wiedzieć o~funkcji print() to to, że wyświetla na~ekranie tekst, ale nie musisz wiedzieć o tym jak to robi.

{\bf Wywołanie funkcji} jest fragmentem kodu który mówi naszemu programowi żeby uruchomił kod wewnątrz funkcji. Na przykład, twój program może wywoływać funkcję print() kiedykolwiek chcesz wyświetlić tekst na~ekranie. Funkcja print() pobiera stringa którego wprowadzasz pomiędzy nawiasami i~drukuje tekst na~ekranie. Ponieważ chcemy wyświetlić na~ekranie tekst Witaj Świecie, piszemy nazwę funkcji, otwierający nawias, string 'Witaj Świecie!' i~nawias zamykający.

\subsection{Funkcja print()}

\bnl{name=hello}
\lstinputlisting[firstline=2,lastline=3,firstnumber=2]{python/hello.py}

Te linie wywołują funkcję {\bf print}, zazwyczaj zapisywaną jako print() (string który chcemy wydrukować na~ekranie jest umieszczony pomiędzy nawiasami).

Nawiasy do~końca nazwy funkcji dodaje się po to, żeby było wiadomo że mówimy o~funkcji o~nazwie print(), nie zmiennej print. Nawiasy na~końcu funkcji przypominają nam że mówimy o~funkcji tak samo, jak cudzysłowie dookoła '42' przypominają nam że mówimy o~stringu '42', nie o~liczbie 42.

Linia 3 to kolejne wywołanie funkcji print(). Tym razem, program pisze ,,Jak się nazywasz?".

\subsection{Funkcja input()}

\bnl{name=hello}
\lstinputlisting[firstline=4,lastline=4,firstnumber=4]{python/hello.py}

Ta linia zawiera instrukcję przypisania, zmienną (imie) i~wywołanie funkcji (input()). Kiedy wywoływane jest input(), program czeka na~tekst od użytkownika. Tekst który wprowadzi użytkownik (czyli twoje imię) staje się wartością zwracaną przez funkcję.

Podobnie jak wyrażenia, wywołania funkcji są ewaluowane do~pojedynczej wartości. Wartość do~której wywołanie funkcji jest ewaluowane nazywa się {\bf wartością zwracaną}. (W~zasadzie, możemy używać słowa ,,zwraca'' zamiast ,,ewaluuje''.) W~tym wypadku, wartość zwracana przez funkcję input() to string który zawiera imię wpisane przez użytkownika. Jeśli użytkownik wpisał Albert, wywołanie funkcji input() jest ewaluowane do~stringa 'Albert'.

Funkcja o~nazwie input() nie potrzebuje (w~przeciwiństwie do~print()) od programu żadnych danych, dlatego nie umieściliśmy nic pomiędzy jej nawiasami.

\bnl{name=hello}
\lstinputlisting[firstline=5,lastline=5,firstnumber=5]{python/hello.py}

W ostatniej linii mamy znów funkcję print(). Tym razem, używamy operatora plus (+) aby skonkatenować stringa 'Miło mi cię poznać, ' i~stringa przechowywanego w~zmiennej o~nazwie \lstinline{imie}, która przechowuje imię które użytkownik wprowadził do~programu. W~ten sposób nauczyliśmy program pozdrawiać nas po imieniu.

\subsection{Kończenie programu}
Kiedy program wykona ostatnią linię, zatrzymuje się. W~tym momencie jest {\bf zakończony} bądź {\bf wyszedł} i~wszelkie zmienne są zapominane przez komputer, włączając stringa przechowywanego w~\lstinline{imie}. Jeśli spróbujesz uruchomić program ponownie podając inne imię, na~przykład Gosia, pomyśli że to twoje imię.

\bl{}
\begin{lstlisting}
Witaj swiecie!
Jak sie nazywasz??
Gosia
Milo mi cie poznac, Gosia
>>> 
\end{lstlisting}

Pamiętaj, komputer robi tylko dokładnie to, co mu powiesz. Tutaj, w~naszym pierwszym programie, jest zaprogramowany by spytać cię o~imię, pozwala ci wpisać tekst, a~potem mówi cześć i~wyświetla tekst który wpisałeś.

Ale komputery są głupie. Program nie ma pojęcia czy wpisujesz swoje imię, imię kogoś innego, czy po prostu coś głupiego. Możesz wpisać cokolwiek chcesz i~komputer potraktuje to w~ten sam sposób:

\bl{}
\begin{lstlisting}
Witaj swiecie!
Jak sie nazywasz??
kupa
Milo mi cie poznac, kupa
>>> 
\end{lstlisting}

\section{Nazwy zmiennych}

Komputerowi jest wszystko jedno jak nazwiesz zmienne, ale tobie nie powinno to być obojętne. Dawanie zmiennym nazw mówiących o~tym, co przechowują sprawia że łatwiej zrozumieć co program robi. Zamiast \lstinline{imie}, mogliśmy nazwać zmienną jaroslawKaczynski lub iMiE.~Komputer uruchomi program tak samo (o~ile nadal będziesz używał nazwy jarosławKaczyński lub iMiE).

Nazwy zmiennych, podobnie jak wszystko inne w~Pythonie, rozróżniają pomiędzy małymi i~wielkimi literami (ang. Case-sensitive). Oznacza to, że ta sama nazwa zmiennej pisana inną wielkością liter uważana jest za zupełnie inną zmienną. Zatem foo, FOO, Foo i~fOO są w~Pythonie czterema różnymi zmiennymi. Każda z~nich może przechowywać inną wartość.

Nie jest najlepszym pomysłem trzymanie zmiennych o~tej samej nazwie różniących się tylko wielkością liter. Jeśli przechowujesz imię użytkownika w~zmiennej \lstinline{IMIE}, a~imię jego psa w~zmiennej \lstinline{imie}, parę tygodni później czytając swój kod nie będziesz wiedział o~co chodzi. Czy \lstinline{IMIE} oznacza imię psa, czy człowieka?

Jeśli przez przypadek zamienisz miejscami zmienne \lstinline{imie} i~\lstinline{IMIE}, twój program będzie działał (to znaczy, nie będzie miał błędów składni), ale będzie się zachowywał nieprawidłowo (zwracając się do~użytkownika per Fafik). Ten typ błędu w~kodzie to {\bf bug}\footnote{czyt. bag}. Często zdarza się przez przypadek pozostawiać w~programie bugi podczas ich pisania. Dlatego właśnie ważne jest, żeby wybierać sensowne nazwy dla zmiennych.

Jeśli nazwa zmiennej składa się z~więcej niż jednego słowa, dobrze jest zaczynać kolejne słowa od wielkiej litery. Jeśli przechowujesz string mówiący o~tym co zjadłeś na~śniadanie, nazwa zmiennej \lstinline{coJadlemNaSniadanie} będzie znacznie łatwiejsza do~odczytania niż \lstinline{cojadlemnasniadanie}. W~programowaniu to {\bf konwencja} - reguła której nie musisz przestrzegać, ale dla większej czytelności powinienneś. (Jeszcze lepiej byłoby nazwać zmienną prościej - dzisiejszeSniadanie). Używanie wielkiej litery na~początku każdego słowa sprawia, że program jest czytelniejszy.

% Paragraph about not using national characters in names - not in original
Zauważyłeś pewnie, że w~nazwie zmiennej jest błąd - słowo imię pisze się z~,,ę'' na~końcu, nie ,,e''. Zrobiłem to jednak celowo. Chociaż możesz używać nazw zmiennych i~funkcji z~polskimi literami (takimi jak ą, ć, ę, ó, ł, ż, ź, ń, ś), najlepiej zastępuj je ich angielskimi odpowiednikami (a, c, e, o, l, z, z, n, s). Python w~najnowszej wersji radzi sobie z~takimi nazwami dość dobrze, ale nie wszyscy używają najnowszych wersji programów. Kiedyś też nauczysz się innego niż Python języka programowania - większość z~nich nie pozwala na~polskie znaki w~nazwach zmiennych i~funkcji, będzie ci ciężko zmienić przyzwyczajenia.

\section{Podsumowanie}

Teraz wiesz już jak radzić sobie z~tekstem, więc możemy zacząć tworzyć programy które użytkownik może uruchamiać i~komunikować się z~nimi. To ważna umiejętność, ponieważ tekst jest głównym sposobem w~który użytkownik będzie się komunikował z~komputerem. Gracz będzie wprowadzał tekst na~ekran poprzez klawiaturę z~pomocą funkcji input(), a~komputer będzie wyświetlał tekst kiedy będzie wykonywana funkcja print().

Stringi są po prostu jeszcze jednym typem danych, któego możemy używać w~programach. Możemy używać operatora + do~,,sklejenia'' stringów razem. Używanie operatora + do~konkatenacji dwóch stringów i~stworzenia nowego działa tak samo jak użycie operatora + do~dodania dwóch liczb, z~których uzyskujemy nową liczbę (sumę).

W następnym rozdziale, nauczymy się więcej o~zmiennych i~nasz program będzie zapamiętywał tekst oraz~liczby wprowadzone przez gracza. Wiedząc jak używać tekstu, liczb i~zmiennych, będziemy gotowi żeby zacząć tworzyć gry.

\chapter{Gra w zgadywanie liczb}

\btopicscovered
	\item Instrukcje \lstinline{import}
	\item Moduły
	\item Argumenty
	\item Instrukcje \lstinline{while}
	\item Warunki
	\item Bloki
	\item Wartości logiczne
	\item Operatory porównania
	\item Różnica pomiędzy \lstinline{=} a \lstinline{==}
	\item Instrukcje \lstinline{if}
	\item Słowo kluczowe \lstinline{break}
	\item Funkcje str() oraz int()
	\item Funkcja random.randint()
\etopicscovered

\section{Zgaduj zgadula}

Napiszemy grę "zgaduj zgadula". Komputer wylosuje liczbę pomiędzy 1 a 20 i poprosi cię o jej odgadnięcie. Dostaniesz tylko sześc prob, ale komputer będzie mówił ci czy twój strzał był zbyt wysoki czy zbyt niski. Jeśli odgadniesz liczbę po sześciu próbach, wygrywasz.

To dobra gra na początek ponieważ używa liczb losowych, pętli i danych od użytkownika w całkiem krótkim kodzie programu. Pisząc ta gre, nauczysz się jak konwertować wartości do różnych typów danych (i dlaczego jest to niezbędne).

Ponieważ nasz program jest grą, będziemy nazywać użytkownika graczem, ale słowo "użytkownik" jest tu także na miejscu.

\subsection{Przykładowa rozgrywka w zgaduj-zgadulę}

Tak gra będzie wyglądała na ekranie gracza kiedy ją uruchomi. Tekst wpisywany przez gracza jest pogrubiony.

\begin{pseudolisting}
Cześć! Jak masz na imię?\linebreak
{\bf Albert}\linebreak
Cześć Albert. Myślę o pewnej liczbie od 1 do 20.\linebreak
Zgaduj:\linebreak
{\bf 10}\linebreak
Strzeliłeś zbyt wysoką liczbę.\linebreak
Zgaduj:\linebreak
{\bf 2}\linebreak
Strzeliłeś zbyt niską liczbę.\linebreak
Zgaduj:\linebreak
{\bf 4}\linebreak
Dobra robota, Albert! Odgadłeś moją liczbę w 3 próbach!\linebreak
\end{pseudolisting}

Przepisz kod źródłowy programu dokładnie tak, jak jest poniżej. Następnie zapisz go klikając na menu File, a następnie Save As. Nazwij go na przykład {\bf zgadula.py}, a następnie uruchom wciskając klawisz F5. Nie martw się jeśli jeszcze nie rozumiesz kodu, wyjaśnię go później krok po kroku.

\subsection{Kod źródłowy zgaduj-zgaduli}

Poniżej znajduje się kod źródłowy gry w zgaduj-zgadulę. Kiedy będziesz wprowadzał kod do edytora, zwróć szczególną uwagę na spacje na początku niektórych linii. Niektóre z linii zaczynają się od 4 albo 8 spacji. Jeśli po uruchomieniu pojawi się błąd, upewnij się że napisałeś program dokładnie tak, jak w książce.

%TODO kod ze strony

{\bf Uwaga!} Ten program działa tylko w wersji 3 Pythona. Jeśli spróbujesz uruchomić go w starszej wersji, pojawi się błąd. Możesz sprawdzić wersję Pythona wybierając w menu Help opcję About IDLE.

\bnl{caption=zgadula.py}
\lstinputlisting{python/zgadula.py}

Pomimo tego, że przepisujesz kod źródłowy do nowego okna edytora, zawsze możesz wrócić do shella żeby wprowadzać pojedyncze instrukcje i sprawdzać co robią. Interaktywny shell jest bardzo dobry do eksperymentowania z instrukcjami bez potrzeby uruchamiania programu. Możesz powrócić do interaktywnego shella klikając na jego okno lub przycisk w pasku zadań. Przycisk okna znajduje się zazwyczaj w pasku zadań (lub docku) na dole ekranu, ale zdarza się że jest przeniesiony na górę.

% TODO diff

Jeśli program po przepisaniu nie wydaje się działać, sprawdź czy przepisałeś kod dokładnie tak, jak w książce. Możesz też skopiować i wkleić swój kod do narzędzia "diff" na stronie http://inventwithpython.com/diff. Narzędzie diff pokaże ci w którym miejscu twój kod źródłowy różni się od tego w książce.

Możesz używać narzędzia diff dla każdego z programów w tej książce.

\section{Instrukcja import}

Przeanalizujmy każdą linię kodu po kolei żeby dowiedzieć się jak działa ten program.

\lstinputlisting[linerange=1-1]{python/zgadula.py}

Ta linia to komentarz. Komentarze wprowadziliśmy już w programie Hello World w rozdziale 3. Pamiętaj, że Python zignoruje wszystko co wpiszesz po znaku \lstinline{#}. Ta linia tylko przypomina nam, co program robi.

\lstinputlisting[linerange=2-2]{python/zgadula.py}

To jest {\bf instrukcja import}. Instrukcje nie są funkcjami (zauważ że ani import ani random nie mają po nazwie nawiasów()). Pamiętaj, że instrukcje wykonują pewne czynności, ale nie są ewaluowane do żadnej wartości. Widziałeś już instrukcje: instrukcje przypisania zapamiętują wartość w zmiennej (ale instrukcja nie jest do niczego ewaluowana).

Chociaż Python ma wiele wbudowanych funkcji, jeszcze więcej jest ich dostępnych w osobnych programach nazywanych modułami. {\bf Moduły} to programy Pythona które zawierają dodatkowe funkcje. Używamy funkcji z tych modułów łącząc je z naszym programem instrukcją \lstinline{import}. W tym wypadku, importujemy moduł \lstinline{random}.

Instrukcja \lstinline{import} składa się ze słowa kluczowego \lstinline{import} oraz nazwy modułu. Razem, słowo kluczowe i nazwa modułu tworzą instrukcję. Linia 2 jest instrukcją import która importuje moduł o nazwie random, który zawiera kilka funkcji związanych z liczbami losowymi. Random po angielsku oznacza właśnie "losowy". (Użyjemy później jednej z tych funkcji, żeby komputer miał liczbę którą gracz ma zgadnąć).

\lstinputlisting[linerange=4-4]{python/zgadula.py}

Ta linia tworzy nową zmienną o nazwie \lstinline{iloscProb}. Będziemy w niej zapamiętywać ile razy gracz próbował odgadnąć liczbę. Ponieważ gracz jeszcze nie próbował, na początek przechowamy tam liczbę 0.

\lstinputlisting[linerange=6-7]{python/zgadula.py}

Linie 6 i 7 powinienneś znać już z programu Witaj Świecie z rozdziału 3. Programiści często używają kodu z wcześniej napisanych programów, żeby nie wynajdować koła od nowa.

Linia 6 jest wywołaniem funkcji print(). Przypomnienie - funkcja jest jak mniejszy program uruchamiany przez nasz program. Kiedy nasz program wywołuje funkcję, uruchamia ten mniejszy program. Kod zawarty w funkcji print() wyświetla na ekranie tekst podany pomiędzy nawiasami.

Po wykonaniu tych dwóch linii, w zmiennej \lstinline{imie} będzie przechowywany string z imieniem gracza. (Pamiętaj, string może nie zawierać naprawdę imienia gracza - będzie zawierał cokolwiek gracz wpisze. Komputery są na tyle głupie, że wykonują program niezależnie od wszystkiego).

\subsection{Funkcja random.randint()}

\lstinputlisting[linerange=9-9]{python/zgadula.py}

W linii 9 wywołujemy nową  funkcję o nazwie \lstinline{randint()}, a następnie przechowujemy wartość przez nią zwróconą w zmiennej o nazwie \lstinline{liczba}. Wywołania funkcji są wyrażeniami, ponieważ są ewaluowane do wartości. Wartość tę nazywamy wartością zwracaną przez funkcję.

Ponieważ funkcja \lstinline{randint()} jest zawarta w module o nazwie \lstinline{random}, poprzedzamy jej nazwę przedrostkiem \lstinline{random.} (razem z kropką!). W ten sposób Python będzie wiedział, że ma szukać funkcji właśnie w tym module.

Funkcja \lstinline{randint()} zwróci losową liczbę całkowitą \footnote{Przypomnienie: liczba całkowita to taka, która nie ma nic po przecinku} z przedziału który jej podamy. Tutaj podaliśmy jej pomiędzy nawiasami liczby 1 i 20 (oddzielone przecinkiem), więc funkcja zwróci liczbę z przedziału domkniętego od 1 do 20. Domknięty oznacza że liczby 1 i 20 mogą również być wylosowane. 

Losowa liczba zwrócona przez randint() jest zapamiętana w zmiennej o nazwie \lstinline{liczba} - będzie to właśnie ta liczba którą gracz musi odgadnąć.

Przejdź na chwilę do okna shella i wpisz \lstinline{import random} żeby zaimportować moduł \lstinline{random}. Potem wpisz \lstinline{random.randint(1,20)} żeby zobaczyć do jakiej wartości funkcja jest ewaluowana. Powinna zwrócić liczbę pomiędzy 1 i 20. Teraz wpisz ten sam kod ponownie i funkcja prawdopodobnie zwróci inną liczbę. Dzieje się tak dlatego, że za każdym razem kiedy funkcja \lstinline{randint()} jest wywoływana, zwraca jakąś liczbę losową, tak jakby rzucała kostką.

\bl{}
\begin{lstlisting}
>>> import random
>>> random.randint(1, 20)
12
>>> random.randint(1, 20)
18
>>> random.randint(1, 20)
3
>>> random.randint(1, 20)
18
>>> random.randint(1, 20)
7
>>>
\end{lstlisting}

Kiedy tylko chcemy żeby nasza gra coś wylosowała, możemy użyć funkcji \lstinline{randint()}. I w większości gier będziemy używać losowania - pomyśl ile znasz gier planszowych w których trzeba rzucać kostką.

Możemy też spróbować losowania liczb z innych zakresów. Na przykład, jeśli wpiszesz \lstinline{random.randint(1,4)}, zobaczysz liczby losowane z zakresu od 1 do 4 włącznie. Jeśli spróbujesz \lstinline{random.randint(1000, 2000)} - dostaniesz liczby pomiędzy 1000 i 2000. Poniżej jest przykład wywoływania funkcji \lstinline{random.randint()} z różnymi argumentami i sprawdzania jakie wartości zwróci. Twoje wyniki będą najprawdopodobniej inne (w końcu to liczby losowe).

\begin{lstlisting}
>>> random.randint(1, 4)
3
>>> random.randint(1, 4)
4
>>> random.randint(1000, 2000)
1294
>>> random.randint(1000, 2000)
1585
>>>
\end{lstlisting}

Możemy zmienić trochę kod gry żeby zachowywała się inaczej. Spróbuj zmienić linie 9 i 10 z takich:

\bnl{}
\lstinputlisting[linerange=9-10]{python/zgadula.py}

na takie:

\bnl{}
\lstinputlisting[linerange=9-10]{python/zgadula100.py}

Teraz komputer wylosuje liczbę od 1 do 100. Zmiana w linii 9 zmieni zakres losowania, ale pamiętaj zmienić też linię 10, żeby gra powiadomiła gracza o nowym przedziale liczb.

\subsection{Wywoływanie funkcji umieszczonych w modułach}

Koniecznie wpisuj \lstinline{random.randint(1, 20)} a nie samo \lstinline{randint(1, 20)}, albo komputer nie będzie wiedział żeby szukać funkcji \lstinline{randint()} w module \lstinline{random} i dostaniesz taki błąd:

\bl{}
\begin{lstlisting}
>>> randint(1, 20)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'randint' is not defined
>>>
\end{lstlisting}

Pamiętaj, twój program musi wykonać instrukcję \lstinline{import random} zanim wywoła funkcję \lstinline{random.randint()}. Dlatego właśnie instrukcje \lstinline{import} znajdują się zazwyczaj na początku programu.

\section{Przekazywanie argumentów do funkcji}

Liczby pomiędzy nawiasami w wywołaniu funkcji \lstinline{random.randint(1, 20)} nazywane są argumentami. {\bf Argumenty} to wartości przekazywane do funkcji kiedy jest wywoływana. Argumenty mówią funkcji jak ma się zachować. Podobnie jak to co wpisze gracz zmienia zachowanie naszego programu, argumenty zmieniają zachowanie funkcji.

Niektóre funkcje wymagają od ciebie podania argumentów. Spójrz na te przykładowe wywołania funkcji:

\bl{}
\begin{lstlisting}
input()
print('Cześć')
random.randint(1, 20)
\end{lstlisting}

Funkcja \lstinline{input()} nie ma argumentów, funkcja \lstinline{print()} ma jeden argument, a funkcja \lstinline{randint()} ma dwa. Kiedy używamy więcej niż jednego argumentu, oddzielamy poszczególne argumenty przecinkami. Inaczej mówiąc, argumenty są oddzielone przecinkami. Dzięki temu komputer wie gdzie kończy się jeden argument, a zaczyna następny.

Jeśli wywołasz funkcję ze zbyt dużą lub małą ilością argumentów, Python wyświetli komunikat o błędzie podobny do tego poniżej. W tym przykładzie, najpierw wywołaliśmy \lstinline{randint()} z jednym argumentem (za mało), a potem - z trzema (za dużo).

\bl{}
\begin{lstlisting}
>>> random.randint(1)
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
random.randint(1)
TypeError: randint() takes exactly 3 positional arguments (2 given)
>>> random.randint(1, 2, 3)
Traceback (most recent call last):
  File "<pyshell#2>", line 1, in <module>
random.randint(1, 2, 3)
TypeError: randint() takes exactly 3 positional arguments (4 given)
>>>
\end{lstlisting}

Komunikaty mówią, że podaliśmy odpowiednio 2 i 4 argumenty, nie 2 i 3. To dlatego że Python zawsze dodaje dodatkowy, niewidoczny argument. Ten argument jest poza zakresem tej książki, i nie musisz się nim martwić.

\section{Powitanie gracza}

Linie 10 i 12 witają gracza, mówią mu o zasadach gry i zaczynają właściwe zgadywanie liczb. Linia 10 jest prosta, ale linia 12 używa nowej konstrukcji nazywanej pętlą.

\bnl{}
\lstinputlisting[linerange=10-10]{python/zgadula100.py}

W linii 10, funkcja print() wita się z graczem po imieniu i mówi mu o tym, że komputer myśli o jakiejś liczbie losowej.

Ale chwila czy nie mówiliśmy że funkcja print() pobiera tylko jednego stringa? Na pierwszy rzut oka może wydawać się, że jest tu więcej niż jeden string, ale przyjrzyj się: operator + łączy wszystkie trzy stringi w jeden, i ten właśnie jeden string jest drukowany przez funkcję print(). Może wydawać się że przecinki oddzielają stringi, ale ponieważ są wewnątrz cudzysłowów, są częściami stringów.

\section{Pętle}

Linia 12 zawiera instrukcję while, która oznacza początek pętli while. {\bf Pętle} to części programu które są wykonywane wiele razy w kółko. Ale zanim omówimy dokładniej pętle, musimy poznać kilka pojęć. Te pojęcia to bloki, zmienne logiczne, operatory porównania i warunki. Dopiero wtedy będziemy gotowi wprowadzić pętlę while.

\section{Bloki}

{\bf Blok} to jedna lub więcej linii kodu zgrupowanych razem za pomocą podobnej ilości wcięć. Można łatwo zobaczyć gdzie blok zaczyna się i kończy patrząc na wcięcia linii (to znaczy, liczbę odstępów na początku linii).

%TODO bełkot
Blok zaczyna się linią z wcięciem długości czterech spacji. Każda kolejna linia która również jest wcięta na 4 spacje jest również częścią bloku. W bloku może znajdować się kolejny blok, kiedy linia jest wcięta na kolejne 4 spacje (czyli łącznie na początku linii jest 8 spacji). Blok kończy się jeśli kolejna linia ma takie wcięcie, jak przed rozpoczęciem bloku.

\img{guess-blocks}{Bloki i odpowiadające im wcięcia. Czarne kropki odpowiadają spacjom.}{7cm}

Spójrz na rysunek \ref{guess-blocks} - oznaczone są na nim wszystkie bloki znajdujące się w kodzie. Spacje zostały zamienione na czarne kropki żeby łatwiej można je było policzyć. Linia 12 nie jest wcięta (nie rozpoczyna się od spacji) i nie jest wewnątrz żadnego bloku. Linia 13 jest wcięta o 4 spacje. Ponieważ jej wcięcie jest większe niż wcięcie poprzedniej linii, możemy powiedzieć że w tym miejscu zaczął się nowy blok. Linie 14, 15, 17 i 19 mają również po cztery spacje wcięcia. Wszystkie z nich mają tyle samo wcięcia co poprzednia linia, więc wiemy że są w tym samym bloku. (Kiedy szukamy bloków, ignorujemy puste linie takie jak 16 czy 18.)

Linia 20 jest wcięta o osiem spacji. Ponieważ osiem spacji to więcej niż cztery, wiemy że zaczyna się nowy blok. Blok wewnątrz innego bloku.

Linia 22 zaczyna się tylko od czterech spacji. Linia która była przed 22 (czyli 20) miała więcej spacji. Ponieważ wcięcie się zmniejsza, wiemy że blok się kończy. Linia 22 jest w tym samym bloku co inne linie z czterema spacjami.

Linia 23 ma większe wcięcie - osiem spacji, rozpoczynając nowy blok.

Kiedy wpisujesz kod do IDLE, każda litera ma taką samą szerokość. Możesz policzyć ilość liter nad lub pod linią żeby zobaczyć ile spacji postawiłeś przed tą linią kodu.

Na rysunku powyżej, linie kodu w ramce 1 wszystkie są w tym samym bloku, a bloki 2 i 3 są wewnątrz bloku 1. Blok 1 jest wcięty o co najmniej cztery spacje, a bloki 2 i 3 - o osiem spacji od lewego marginesu. Blok może składać się tylko z jednej linii - dowodem na to są bloki 2 i 3.

\section{Wartości logiczne}

Wartości logiczne (boolowskie) to typ danych który może przyjmować tylko dwie wartości: Prawda (ang. True) lub Fałsz (ang. False). Te wartości muszą być pisane z dużej litery i nie są stringami, czyli {\bf nie} mogą "znajdować się w cudzysłowiach". Będziemy używać wartości logicznych z operatorami porównania do tworzenia warunków. Wszystko jest wyjaśnione poniżej.

\section{Operatory porównania}

Linia 12 naszego programu zawiera pętlę while:

\bnl{}
\lstinputlisting[linerange=12-12]{python/zgadula.py}

Wyrażenie które występuje po słowie kluczowym \lstinline{while} (czyli \lstinline{iloscProb < 6}) składa się z dwóch wartości (wartość przechowywana w zmiennej \lstinline{iloscProb} i liczba człkowita 6) połączonych operatorem (znak \lstinline{<}, czyli "mniejsze niż"). Znak \lstinline{<} nazywany jest {\bf operatorem porównania}.

Operator porównania jest używany do porównywania dwóch wartości i jest ewaluowany do wartości logicznej True (prawda) lub False (fałsz). Lista wszystkich operatorów porównania znajduje się w tabelce \ref{comparison-operators}.

\begin{table}[here]
\caption{Operatory porównania}
\centerline{
\begin{tabular}{| c | l | }
\hline
Znak & Nazwa operatora\\
\hline
\lstinline{<} & Mniejsze niż\\
\hline
\lstinline{>} & Większe niż\\
\hline
\lstinline{<=} & Mniejsze lub równe\\
\hline
\lstinline{>=} & Większe lub równe\\
\hline
\lstinline{==} & Równe\\
\hline
\lstinline{!=} & Nierówne\\
\hline
\end{tabular}
}
\label{comparison-operators}
\end{table}

\section{Warunki}

{\bf Warunek} to wyrażenie które łączy dwie wartości operatorem porównania (takim jak \lstinline{<} czy \lstinline{>}) i które jest ewaluowane do wartości logicznej. Warunek to inna nazwa wyrażenia które jest ewaluowane do True albo False (prawda / fałsz). Lista innych operatorów porównania znajduje się w tabeli \ref{comparison-operators}.

Warunki zawsze są ewaluowane do zmiennej logicznej: True lub False. Na przykład, warunek który znajduje się w naszym kodzie, \lstinline{liczbaProb < 6} zadaje pytanie: "czy wartość przechowywana w \lstinline{liczbaProb} jest mniejsza niż liczba 6?" Jeśli tak, warunek jest ewaluowany do True (prawda). Jeśli nie, wynikiem ewaluacji jest False (fałsz).

W przypadku naszej zgaduj-zgaduli, w linii 4 przechowaliśmy wartość 0 w zmiennej \lstinline{liczbaProb}. Ponieważ 0 to mniej niż 6, wynikiem warunku jest True (prawda). Zapamiętaj - warunek to tylko inna nazwa dla wyrażenia które używa operatorów porównania takich jak \lstinline{<} czy \lstinline{!=}.

\section{Eksperyment ze zmiennymi logicznymi, operatorami porównania i warunkami}

Wprowadź poniższe wyrażenia do interaktywnego shella żeby zobaczyć jakie są ich wartości logiczne:
\bl{}
\begin{lstlisting}
>>> 0 < 6
True
>>> 6 < 0
False
>>> 50 < 10
False
>>> 10 < 11
True
>>> 10 < 10
False
\end{lstlisting}

Warunek \lstinline{0 < 6} zwraca logiczną prawdę (True) ponieważ liczba 0 jest mniejsza niż liczba 6. Ale ponieważ 6 nie jest mniejsze niż 0, warunek \lstinline{6 < 0} zwraca fałsz (False). 50 nie jest mniejsze niż 10, dlatego \lstinline{50 < 10} to fałsz. 10 to mniej niż 11, więc \lstinline{10 < 11} to prawda.

Ale co z \lstinline{10 < 10}? Dlaczego zwraca fałsz? Wyrażenie to jest fałszywe ponieważ liczba 10 nie jest mniejsza od siebie samej. Są dokładnie takie same. Jeśli dziewczyna o imieniu Ala ma taki sam wzrost jak chłopak o imieniu Piotrek, nie powież że Ala jest wyższa od Piotrka lub że Ala jest od Piotrka niższa. Oba zdania byłyby nieprawdziwe.

Spróbuj wpisać w shellu jeszcze kilka wyrażeń żeby zobaczyć jak działają takie operatory porównania:
\bl{}
\begin{lstlisting}
>>> 10 == 10
True
>>> 10 == 11
False
>>> 11 == 10
False
>>> 10 != 10
False
>>> 10 != 11
True
>>> 'Cześć' == 'Cześć'
True
>>> 'Cześć' == 'Do widzenia'
False
>>> 'Cześć' == 'CZEŚĆ'
False
>>> 'Do widzenia' != 'Cześć'
True
\end{lstlisting}

Zauważ różnicę między operatorem przypisania (\lstinline{=}) a operatorem porównania "równa się" (\lstinline{==}). Znak \lstinline{=} używany jest żeby nadać zmiennej wartość, podczas kiedy operator \lstinline{==} jest używany w wyrażeniach żeby sprawdzić czy dwie wartości są równe. Łatwo jest je pomylić, więc pisz uważnie.

Dwie wartości które są różnych typów danych nigdy nie będą równe. Spróbuj na przykład wpisać w shellu poniższe wyrażenia:

\bl{}
\begin{lstlisting}
>>> 42 == 'Hello'
False
>>> 42 != '42'
False
\end{lstlisting}

\section{Pętle while}

Słowo kluczowe \lstinline{while} (dopóki) oznacza początek pętli. Czasem chcemy żeby program robił coś w kółko. Kiedy podczas wykonywania programu komputer dojdzie do słowa \lstinline{while}, ewaluuje warunek znajdujący się tuż za nim. Jeśli warunek ewaluuje do True (jest prawdziwy), wykonuje polecenia wewnątrz ciała pętli (w naszym programie jest to blok który zaczyna się od linii 13). Jeśli warunek ewaluuje do False (jest fałszywy), wykonywany jest kod za ciałem pętli (w naszym programie - od linii 28).

Instrukcja \lstinline{while} zawsze kończy się dwukropkiem po warunku.

\bnl{}
\lstinputlisting[linerange=12-12]{python/zgadula.py}

\img{guess-loop}{Warunek pętli while}{7 cm}

Rysunek \ref{guess-loop} pokazuje jak wykonywany jest program w zależności od warunku. Jeśli warunek jest prawdziwy (jest ewaluowany do True), komputer zacznie wykonywać ciało pętli w linii 13 i kolejnych. Kiedy program osiągnie koniec ciała pętli (linia 26), wraca do linii z instrukcją \lstinline{while} (linia 12). Wtedy ewaluuje warunek po raz kolejny, i jeśli jego wartość to True, wykonuje blok while po raz kolejny. 

W naszym programie, za pierwszym razem warunek pętli while jest prawdziwy, ponieważ \lstinline{liczbaProb} jest równa 0.

Tak działa pętla. Dopóki (ang. while) warunek jest prawdziwy, program wykonuje kod wewnątrz ciała pętli (bloku while) w kółko aż osiągnie koniec ciała pętli i warunek będzie fałszywy. Czyli do kiedy \lstinline{liczbaProb} nie jest równa ani większa niż 6, wykonywana jest pętla.

Wykonanie instrukcji while jest jak powiedzenie "dopóki ten warunek jest prawdziwy, ciągle wykonuj kod w tym bloku".

% Minipage prevents page breaks
% http://www.tex.ac.uk/cgi-bin/texfaq2html?label=nopagebrk
\begin{minipage}{1\linewidth}
Możesz uprościć lub utrudnić grę zmieniając dozwoloną liczbę prób. Wszystko co musisz zrobić to zmienić linię:
\bnl{}
\lstinputlisting[linerange=12-12]{python/zgadula.py}
na
\bnl{}
\lstinputlisting[linerange=12-12]{python/zgadula4.py}
...i gracz dostaje tylko cztery próby zamiast sześciu.
\end{minipage}

Ustawiając warunek na \lstinline{liczbaProb < 4}, upewniamy się że kod wewnątrz pętli wykonywany jest tylko cztery razy zamiast sześciu. To sprawia że gra jest trudniejsza. Żeby uprościć grę, ustaw warunek na \lstinline{liczbaProb < 8} lub \lstinline{liczbaProb < 10}, co spowoduje że pętla zostanie wykonana więcej razy i program przyjmie większą liczbę prób.

Oczywiście, jeśli usunęlibyśmy linię 17 (\lstinline{liczbaProb = liczbaProb + 1}), liczbaProb nigdy by się nie zwiększała i warunek zawsze byłby prawdziwy. To dawałoby graczowi nieskończoną liczbę prób.

\section{Strzały gracza}

Linie od 13 do 17 pytają gracza o liczbę i pozwalają mu wprowadzić strzał. Liczbę którą wpisał przechowujemy w zmiennej, a następnie zamieniamy stringa na liczbę całkowitą.

\lstinputlisting[linerange=13-14]{python/zgadula.py}

Program pyta gracza o strzał. Gracz wpisuje strzał i to, co wpisał, jest przechowywane w zmiennej o nazwie \lstinline{strzal}.

\subsection{Konwersja stringów na liczby całkowite za pomocą funkcji int()}

\lstinputlisting[linerange=15-15]{python/zgadula.py}

W linii 15 wywołujemy nową funkcję o nazwie \lstinline{int()}. Funkcja \lstinline{int()} dostaje jeden argument. Funkcja \lstinline{input()} zwróciła to, co wpisał gracz w postaci stringa. Ale nasz program potrzebuje liczby całkowitej, a nie stringa. Jeśli gracz wpisze 5, funkcja \lstinline{input()} zwróci stringa '5', a nie liczbę całkowitą 5. Pamiętaj, że Python uważa że string '5' i liczba 5 to dwie różne wartości. Funkcja \lstinline{int()} pobierze stringa i zwróci jego wartość w postaci liczby całkowitej. Zamiana jednego typu danych na inny to {\bf konwersja}.

Poeksperymentujmy z funkcją \lstinline{int()}. Spróbuj wpisać poniższe linie:

\bl{}
\begin{lstlisting}
>>> int('42')
42
>>> int(42)
42
>>> int('czesc')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: 'czesc'
>>> int('czterdzieści dwa')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'decimal' codec can't encode character '\u015b' in position 9: invalid decimal Unicode string
>>> int(' 42 ')
42
>>> 3 + int('2')
5
>>> 3 + '2'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'str'
\end{lstlisting}

Widzimy że wyrażenie \lstinline{int('42')} zwróci liczbę całkowitą 42, i że \lstinline{int(42)} zwróci dokładnie to samo (chociaż zamiana liczby całkowitej na liczbę całkowitą nie ma przecież sensu). Ale pomimot tego że do funkcji \lstinline{int()} da się przekazać stringa, nie oznacza to że może on zawierać cokolwiek. Na przykład przekazanie do funkcji \lstinline{int()} stringa 'czesc' spowoduje błąd. Tekst przekazywany do \lstinline{int()} musi składać się z cyfr.


Liczba którą przekazujemy do \lstinline{int()} musi składać się z cyfr, dlatego \lstinline{int('czterdzieści dwa')} również spowodowało błąd. Ale jeśli string zawiera spacje, funkcja \lstinline{int()} będzie udawała że ich nie widzi - dlatego zadziałał przykład \lstinline{int(' 42 ')}.

W linii \lstinline{3 + int('2')} wypróbowaliśmy wyrażenie które dodaje liczbę 3 do wartości zwracanej przez \lstinline{int('2')} (czyli liczby 2). Wyrażenie jest ewaluowane do \lstinline{3+2}, co z kolei jest ewaluowane do 5. W następnym przykładzie że bez konwersji nie da się dodać liczby (3) do stringa ('2'), ale można dodać liczbę do stringa którego skonwertowaliśmy na liczbę.

W linii 15 naszego programu zmienna \lstinline{strzal} przechowywała string wpisany przez gracza. Nadpiszemy stringa przechowywanego w zmiennej \lstinline{strzal} wartością zwracaną przez funkcję \lstinline{int()}. Robimy to po to, żebyśmy mogli później porównać strzał gracza z liczbą wylosowaną przez komputer. Żeby sprawdzić czy strzał gracza jest zbyt niski czy zbyt wysoki, musimy porównać dwie liczby. Nie możemy porównać stringa z liczbą żeby sprawdzić który jest mniejszy a który większy, nawet jeśli string składa się z cyfr, na przykład '5'.

W naszej zgaduj-zgaduli jeśli gracz wpisze coś co nie jest liczbą, wywołanie funkcji int() spowoduje błąd i program przestanie działać. W innych grach w tej książce dodamy trochę kodu który będzie sprawdzał czy nie wystąpił błąd i dawał graczowi szansę poprawienia wpisanej wartości.

Zauważ że wywołanie \lstinline{int(strzal)} nie zmienia wartości zmiennej \lstinline{strzal}. Kod \lstinline{int(strzal)} to wyrażenie które jest ewaluowane do liczbowej wersji stringa \lstinline{strzal}. Żeby zminenić zawartość zmiennej, musimy przypisać wartość zwracaną przez to wyrażenie do zmiennej \lstinline{strzal} w ten sposób: \lstinline{strzal = int(strzal)}.

\subsection{Inkrementacja zmiennych}

\lstinputlisting[linerange=17-17]{python/zgadula.py}

Kiedy gracz odda strzał, chcemy zwiększyć ilość oddanych strzałów które przechowujemy.

Za pierwszym razem kiedy program wchodzi do pętli while, zmienna \lstinline{iloscProb} ma wartość 0. Python odczyta jej wartość i doda do niej 1. 0 + 1 to 1. Potem zapisze wynik dodawania (1) z powrotem do \lstinline{iloscProb}.

Linia 17 mówi "zmienna \lstinline{iloscProb} powinna być o 1 większa niż jest obecnie".

Kiedy programiści dodają jedynkę do wartości zmiennej przechowującej liczbę całkowitą, mówią że {\bf inkrementują} tą zmienną. Kiedy odejmują 1 od jej wartości, {\bf dekrementują} zmienną. Następnym razem kiedy ciało pętli będzie się wykonywać, \lstinline{iloscProb} będzie miało wartość 1 i zostanie inkrementowane do wartości 2.

\section{Instrukcje if}

\subsection{Czy strzał gracza jest zbyt niski?}

Linie 19 i 20 sprawdzają czy liczba którą wprowadził gracz jest mniejsza niż liczba wylosowana przez komputer. Jeśli tak, mówimy graczowi że strzelił zbyt nisko drukując wiadomość na ekranie.

\lstinputlisting[linerange=19-20]{python/zgadula.py}

Linia 19 rozpoczyna instrukcję \lstinline{if} słowem kluczowym \lstinline{if}. Za słowem \lstinline{if} znajduje się warunek. W linii 20 zaczyna się nowy blok (co widać po tym, że wcięcie jest większe niż w linii 19). Blok który znajduje się za słowem kluczowym \lstinline{if} nazywa się blokiem if. Wyrażenie \lstinline{if} (ang. jeśli) używane jest wtedy, kiedy chcesz żeby fragment kodu wykonał się tylko jeśli jakiś warunek jest prawdziwy. Linia 19 zawiera instrukcję z warunkiem \lstinline{strzal < liczba}. Jeśli warunek jest prawdziwy (to znaczy, jest ewaluowany do \lstinline{True}), wtedy wykonywany jest blok if. Jeśli warunek jest fałszywy, kod w bloku if jest pomijany.

Jeśli liczba wprowadzona przez gracza jest mniejsza niż liczba wylosowana przez komputer, program wyświetla \lstinline{Strzeliłeś zbyt małą liczbę}. Jeśli liczba którą gracz wprowadził jest równa lub większa niż liczba wylosowana (czyli warunek \lstinline{strzal < liczba} jest fałszywy), blok if nie zostaje wykonany.

\img{guess-keyword-condition}{Instrukcje if i while}{7 cm}

\subsection{Czy strzał gracza jest zbyt wysoki?}

Linie od 22 do 26 sprawdzają czy strał gracza był większy bądź dokładnie równy wylosowanej liczbie.

\lstinputlisting[linerange=22-23]{python/zgadula.py}

Jeśli strzał gracze jest większy niż wylosowana liczba, wykonywany jest blok znajdujący się za instrukcją \lstinline{if}. Funkcja \lstinline{print()} w linii 23 mówi graczowi, że liczba którą odgadł jest zbyt duża.

Podobnie jak instrukcja while, instrukcja if składa się również ze słowa kluczowego, warunku, dwukropka, i bloku kodu. Spójrz na porównanie tych instrukcji na rysunku \ref{guess-keyword-condition}.

Instrukcja if działa prawie tak samo jak instrukcja while. Różnią się tym, że kiedy \lstinline{if} skończy wykonywać blok, nie skacze z powrotem do początku - po prostu wykonuje program dalej. Inaczej mówiąc, instrukcje if nie są pętlami.

Jeśli warunek jest prawdziwy, wykonują się wszystkie liczby z bloku if. Jedyna linia w tym bloku to linia 23, która wywołuje funkcję print().

\section{Przerywanie pętli za pomocą instrukcji break}

\lstinputlisting[linerange=25-26]{python/zgadula.py}

Warunek tej instrukcji if sprawdza czy strzał jest taki sam jak wylosowana liczba. Jeśli tak, wykonywany jest blok składający się z linii 26.

Linia wewnątrz bloku if zawiera instrukcję {\bf break} (ang. przerwij) która nakazuje programowi wyskoczyć z pętli do pierwszej linii za jej ciałem (28). Instrukcja break nie sprawdza warunku zakończenia pętli tylko przerywa ją niezależnie od wszystkiego.

Instrukcja break składa sie tylko ze słowa \lstinline{break} bez żadnych warunków ani dwukropków.

Jeśli strzał gracza nie jest równy wylosowanej liczbie, nie wyskakujemy z pętli. Ale linia 26 zawierająca instrukcję \lstinline{break} jest ostatnią linią ciała pętli, więc program wróci do początku i sprawdzi warunek z linii 12 (\lstinline{iloscProb < 6}). Ponieważ w międzyczasie została wykonana linia \lstinline{iloscProb = iloscProb + 1}, zmienna \lstinline{iloscProb} ma teraz wartość 1. Ponieważ 1 to mniej niż 6, pętla wykonywana jest kolejny raz.

Jeśli gracz będzie odgadywał nieprawidłowe liczby (za duże lub za małe), zmienna \lstinline{iloscProb} będzie zmieniała wartość na 2, potem 3, 4, 5 i na końcu 6. Jeśli gracz prawidłowo odgadł liczbę, warunek w instrukcji \lstinline{if strzal == liczba} będzie prawdziwy i zostanie wykonana instrukcja \lstinline{break}. Jeśli liczba była nieprawidłowa, pętla będzie wykonana jeszcze raz. Ale kiedy zmienna \lstinline{iloscProb} przechowuje liczbę 6, warunek w instrukcji \lstinline{while} (\lstinline{iloscProb < 6}) jest fałszywy ponieważ 6 nie jest mniejsze niż 6.  Ponieważ warunek jest fałszywy, ciało pętli nie jest wykonywane kolejny raz, i program przeskakuje do kolejnej linii (czyli 28).

Pozostała część kodu jest wykonywana kiedy gracz skończył zgadywać (dlatego że odgadł prawidłową liczbę albo próbował zbyt wiele razy). W zależności od tego dlaczego pętla przestała się wykonywać okaże się czy gracz wygrał czy przegrał. Program sprawdzi to i wyświetli komunikat o wygranej lub przegranej.

\section{Sprawdzanie czy gracz wygrał}

\lstinputlisting[linerange=28-28]{python/zgadula.py}

W przeciwieństwie do linii 25, ta linia nie jest wcięta, co oznacza że blok z ciałem pętli while się zakończył, a linia 28 to pierwsza linia poza tym blokiem. Opuściliśmy ciało pętli albo dlatego że warunek pętli while był fałszywy (gracz zbyt wiele razy odgadnął złą liczbę) albo dlatego, że wykonaliśmy instrukcję \lstinline{break} (gracz odgadł liczbę). W linii 28 sprawdzamy jeszcze raz czy gracz odgadnął liczbę. Jeśli tak, wykonujemy blok if:

\lstinputlisting[linerange=29-30]{python/zgadula.py}

Linie 29 i 30 znajdują się wewnątrz bloku if. Wykonywane są tylko kiedy warunek w linii 28 był prawdziwy, czyli jeśli gracz poprawnie odgadnął liczbę.

W linii 29 wywołujemy nową funkcję \lstinline{str()}, która zamienia argument na stringa. Używamy tej funkcji ponieważ chcemy zamienić liczbę całkowitą ze zmiennej \lstinline{iloscProb} na stringa który można wydrukować na ekranie. Argument funkcji \lstinline{print()} musi być stringiem.

Linia 30 mówi graczowi że wygrał i ile razy musiał zgadywać zanim mu się udało. Zauważ że dodajemy (konkatenujemy) tutaj stringi do zmiennej \lstinline{iloscProb}. Gdybyśmy nie zamienili jej wcześniej na stringa, Python zgłosiłby błąd ponieważ nie da się dodać stringa do liczby całkowitej.

\subsection{Sprawdzanie czy gracz przegrał}

\lstinputlisting[linerange=32-32]{python/zgadula.py}

W linii 32 używamy operatora porównania \lstinline{!=} jako warunku w instrukcji \lstinline{if}. Operator ten oznacza "nie jest równe". Jeśli wartość którą gracz wpisał jako ostatnią jest większa lub mniejsza niż liczba wylosowana przez komputer (czyli nie jest równa), ten warunek jest prawdziwy (jest ewaluowany do True), i wchodzimy do bloku który zaczyna się tuż za instrukcją \lstinline{if}, w linii 33.

Linie 33 i 34 znajdują się wewnątrz bloku if i wykonują się tylko kiedy warunek jest prawdziwy:

\lstinputlisting[linerange=33-34]{python/zgadula.py}

W tym bloku mówimy graczowi jaka była wylosowana liczba której nie udało mu się odgadnąć. Ale wpierw musimy zamienić ją na stringa, żeby dało się ją wydrukować na ekranie.

Dotarliśmy do miejsca w którym kończy się kod, a program przestaje się wykonywać.

Gratulacje! Napisaliśmy właśnie pierwszą prawdziwą grę!

\section{Podsumowanie: Czym właściwie jest programowanie?}

Jeśli ktoś spytałby cię czym jest programowanie, jak mógłbyś mu odpowiedzieć? Programowanie to wpisywanie kodu programów, to znaczy, tworzenie programów które są wykonywane przez komputer.

"Ale czym właściwie jest program?" Jeśli widzisz kogoś kto używa programu na komputerze (na przykład, gra w naszą zgaduj-zgadulę), widzisz tylko tekst pojawiający się na ekranie. Program decyduje jaki dokładnie tekst ma pojawić się na ekranie (ten tekst to {\bf wyjście} programu). Decyzje są podejmowane na podstawie instrukcji (czyli programu) i tekstu który gracz wpisał na klawiaturze (ten tekst to \bf{wejście} programu). Program ma bardzo szczegółowe instrukcje mówiące o tym jaki tekst ma pokazywać użytkownikowi. Program jest po prostu zestawem instrukcji.

"Jakiego rodzaju instrukcji?" Jest kilka różnych rodzajów instrukcji.

\begin{enumerate}
\item Wyrażenia które składają sie z wartości połączonych operatorami. Wyrażenia są ewaluowane do pojedynczej wartości, tak jak \lstinline{2 + 2} jest ewaluowane do \lstinline{4}, albo \lstinline{'Witaj' + ' ' + 'świecie'} jest ewaluowane do \lstinline{'Witaj świecie'}. Wywołania funkcji mogą również być częścią wyrażeń ponieważ one też są ewaluowane do pojedynczej wartości, i ta wartość może być połączona operatorami z innymi wartościami. Kiedy wyrażenia znajdują się za słowami kluczowymi \lstinline{if} lub \lstinline{while}, nazywamy je warunkami.
\item Instrukcje przypisania, które przechowują wartości w zmiennych żebyśmy mogli używać ich w dalszej części programu
\item \lstinline{if}, \lstinline{while} i \lstinline{break} to {\bf instrukcje sterujące} ponieważ decydują o tym które linie programu zostaną wykonane, a które nie. Normalna kolejność wykonania programu jest taka że zaczyna się na górze ekranu i wykonuje linia po linii aż do końca. Ale instrukcje sterujące sprawiają że niektóre linie nie są wykonywane, a inne są wykonywane po kilka razy. Wywołania funkcji również zmieniają kolejność wykonania programu ponieważ skaczą do początku kodu funkcji.
\item Funkcja \lstinline{print()}, która drukuje tekst na ekranie oraz funkcja \lstinline{input()} która pobiera tekst wpisany przez użytkownika. Funkcje tego typu nazywają {\bf wejściem/wyjściem} (I/O) poniewż kontrolują wejście oraz wyjście programu.
\end{enumerate}

To wszystko, tylko te cztery rzeczy. Oczywiście jest wiele szczegółów związanych z tymi czterema rodzajami instrukcji. W tej książce dowiesz się o nowych typach danych i operatorach, nowych instrukcjach sterujących innych niż \lstinline{if}, \lstinline{while} i \lstinline{break} i kilku nowych funkcjach. Są również różne rodzaje I/O (wejście: myszka, wyjście: dźwięk, grafika, obrazki).

Osobę korzystającą z naszych programów interesuje tylko ostatni rodzaj instrukcji - I/O. Użytkownik pisze na klawiaurze i widzi na ekranie odpowiedź lub słyszy coś w głośnikach. Ale żeby komputer wiedział jakie ma pokazywać znaki i odtwarzać dźwięki - potrzebuje programu, a program to lista instrukcji którą napisałeś ty - programista.



\end{document}
