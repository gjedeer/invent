\documentclass{book}
\usepackage[pdftex,plainpages=false,pdfpagelabels,pdfstartpage=1,pdfstartview=FitH]{}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[polish]{babel}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}

% Original author: Al Sweigart, http://inventwithpython.com/
% License: BY-NC-SA, http://creativecommons.org/licenses/by-nc-sa/3.0/us/
% Translation: GDR!, http://gdr.geekhood.net/

\onehalfspacing

% According to polish grammar rules, you have to put dots after numerals in chapter, section, subsection, etc. headers.
\renewcommand\thechapter{\arabic{chapter}.}
\renewcommand\thesection{\arabic{chapter}.\arabic{section}.}
\renewcommand\thesubsection{\arabic{chapter}.\arabic{section}.\arabic{subsection}.}
\renewcommand\thesubsubsection{\arabic{chapter}.\arabic{section}.\arabic{subsection}.%
                                                           \arabic{subsubsection}.}
% It's customary (depends on publisher) to indent first paragraph in sections and chapters:
\usepackage{indentfirst}
\lstset{extendedchars=false}

% Fixes a bug in lstlisting
\lstset{extendedchars=false}

% Image macro
\newcommand{\img}[3]{
\begin{figure}
\centerline{
	\includegraphics[width=#3]{#1.png}
}
\caption{#2}
\label{#1}
\end{figure}
}

% Topics covered 
\definecolor{topicscoveredbg}{gray}{0.9}
          
\makeatletter\newenvironment{graybox}{%
\begin{lrbox}{\@tempboxa}\begin{minipage}{\columnwidth}}{\end{minipage}\end{lrbox}%
\colorbox{topicscoveredbg}{\usebox{\@tempboxa}}
}\makeatother

\newcommand{\btopicscovered}{
	\begin{graybox}
	\begin{itemize}
}
\newcommand{\etopicscovered}{
	\end{itemize}
	\end{graybox}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\chapter{Instalowanie Pythona}

\chapter{Shell interaktywny}
\btopicscovered
	\item Liczby całkowite i zmiennoprzecinkowe
	\item Wyrażenia
	\item Wartości
	\item Operatory
	\item Ewaluacja wyrażeń
	\item Przechowywanie wartości w zmiennych
	\item Nadpisywanie zmiennych
\etopicscovered

Zanim rozpoczniemy pisać gry komputerowe, powinniśmy poznać kilka pojęć związanych z~programowaniem. Chodzi o~wartości, operatory, wyrażenia i~zmienne. Nie zaczniemy jeszcze w~tym rozdziale pisać programów, ale poznanie tych pojęć i~różnych nazw bardzo uprości dalszą naukę. To dlatego, że większa część programowania to tylko kilka prostych pomysłów połączonych w~całość i~tworzących duże programy.

Zacznijmy od nauczenia się jak używać interaktywnego shella Pythona.

\section{Trochę prostej matematyki}

% Tego akapitu nie było w oryginale
Python posiada interaktywnego shella o nazwie IDLE. Interaktywność oznacza że reaguje on na wszystkie twoje polecenia zaraz po ich wpisaniu (nieinterkatywny tryb pracy to taki w którym wpierw wpisujesz wszystkie polecenia do pliku, a dopiero potem są one wykonywane po kolei). Shell\footnote{Shell jest przez niektórych nazywany również "powłoką". Zabawne, prawda?} to miejsce gdzie wpisujesz polecenia - zgłasza się znakiem \lstinline{>>>} nazywanym znakiem zachęty (lub promptem).

Żeby otworzyć IDLE na Windowsie, kliknij na Start, Programy, Python 3.1 a~potem IDLE (Python GUI). Zaczniemy od kilku prostych obliczeń w~Pythonie. Interaktywny shell może działać jak kalkulator. Wpisz w~okno shella 2+2 i~wciśnij Enter na klawiaturze (na niektórych klawiaturach ten klawisz to Return). Jak widzisz na rysunku~\ref{idle-dwaplusdwa}, komputer powinien odpowiedzieć liczbą 4, sumą 2+2.

\img{idle-dwaplusdwa}{Wpisz w okno shella 2+2}{7cm}

Jak widzisz, możemy używać shella Pythona jako kalkulatora. To co zrobiłeś nie jest jeszcze programem, ponieważ dopiero uczymy się podstaw. Znak + każe komputerowi dodać liczby 2 i~2. Aby odjąć liczby, użyj znaku -, żeby je pomnożyć użyj gwiazdki (*), i tak dalej:

\begin{table}[here]
\caption{Różne operatory matematyczne w~Pythonie}
\centerline{
\begin{tabular}{| c | c | }
\hline
2+2 & dodawanie\\
\hline
2-2 & odejmowanie\\
\hline
2*2 & mnożenie\\
\hline
2/2 & dzielenie\\
\hline
\end{tabular}
}
\label{hops-algo}
\end{table}

Znaki +, -, * i~/ kiedy używa się ich w~ten sposób, są nazywane {\bf operatorami} ponieważ mówią komputerowi żeby wykonał jakąś operację na liczbach które je otaczają.

\subsection{Liczby całkowite i~zmiennoprzecinkowe}

W programowaniu (a~także matematyce), liczby takie jak 4, 0 czy 99 nazywane są {\bf całkowitymi}. Liczby z~ułamkami bądź kropką dziesiętną\footnote{W matematyce do oddzielania części całkowitej od ułamkowej używa się przecinka, w~programowaniu - zazwyczaj jest to kropka.} (jak 3.5, 42.1, 5.0) nie są całkowite. W~Pythonie, liczba 5 jest całkowita, ale jeśli zapiszemy ją jako 5.0 - już nie. Liczby z~kropką dziesiętną nazywają się {\bf liczbami zmiennoprzecinkowymi}. W~matematyce, 5.0 ciągle pozostaje liczbą całkowitą i ma tą samą wartość co 5, ale komputer traktuje liczby całkowite i zmiennoprzecinkowe inaczej.

\subsection{Wyrażenia}

Spróbuj wpisać któreś z~tych działań do shella, wciskając po każdym z~nich Enter.

\begin{lstlisting}
2+2+2+2+2
8*6
10-5+6
2  +       2      
\end{lstlisting}

\img{idle-wyrazenia}{Okno IDLE po wykonaniu wyrażeń}{7cm}

Te działania matematyczne nazywane są wyrażeniami. Komputery potrafią rozwiązać miliony tego typu zadań w~ciągu sekundy. Wyrażenia są złożone z~{\bf wartości} (liczb) połączonych {\bf operatorami} (symbolami matematycznymi). Dowiedzmy się czym dokładnie są wartości i~operatory.

\img{idle-wyroperwart}{Wyrażenie składa się z wartośći i operatorów}{3cm}

W ostatnim wyrażeniu w przykładach wyżej mogłeś się przekonać, że można użyć dowolnej ilości spacji (odstępów) pomiędzy liczbami oraz operatorami. Pamiętaj jednak, żeby zawsze zaczynać pisać od samego początku linii, nie wstawiając dodatkowych odstępów przed pierwszą liczbą.

Liczba jest rodzajem wartości. Liczba całkowita jest rodzajem liczby. Ale, chociaż liczby całkowite są liczbami, nie wszystkie liczby są liczbami całkowitymi (na przykład, ułamki i~liczby z~kropką dziesiętną jak 2.5 są liczbami ale nie są całkowite).

To podobnie jak kot jest rodzajem zwierzęcia domowego, ale nie wszystkie zwierzęta domowe są kotami. Są przecież ludzie którzy mają psy lub kraby. 

{\bf Wyrażenie} składa się z~wartości (na przykład liczb całkowitych takich jak 8 czy 6) połączonych operatorem (takim jak znak mnożenia *). Pojedyncza wartość bez operatorów też traktowana jest jak wyrażenie.

W następnym rozdziale nauczymy się jak pracować z~wyrażeniami tekstowymi. Python nie jest ograniczony do liczb. Umie wiele więcej niż zwykły kalkulator.

\section{Ewaluacja wyrażeń}

Kiedy komputer rozwiązuje wyrażenie 10+5 i~otrzymuje wartość 15, mówimy że {\bf ewaluuje} (oblicza) wyrażenie. Ewaluacja wyrażenia zamienia je w~pojedynczą wartość, podobnie jak rozwiązanie zadania matematycznego zamienia je w~pojedynczą liczbę: rozwiązanie.

Wyrażenia 10+5 oraz 10+3+2 mają tą samą wartość, ponieważ oba są ewaluowane do 15. Nawet pojedyncze wartości są wyrażeniami: wyrażenie 15 ewaluuje się do wartośći 15.

Jeśli jednak wpiszesz w~interaktywnym shellu tylko 5+, dostaniesz wiadomość o~błędzie.
\lstset{language=python}
\begin{lstlisting}{}
>>> 5 +
SyntaxError: invalid syntax
\end{lstlisting}

Ten błąd zdarzył się ponieważ 5+ nie jest wyrażeniem. Wyrażenia to wartości połączone operatorami, a~operator + zawsze spodziewa się dwóch wartości. My podaliśmy mu tylko jedną. Dlatego właśnie pojawił się komunikat o~błędzie. Błąd składni (Syntax Error) oznacza, że komputer nie rozumie instrukcji którą mu podałeś ponieważ wpisałeś ją nieprawidłowo. Python zawsze wyświetli błąd jeśli wprowadzisz instrukcję której nie zrozumie.

To może nie wydawać się w tej chwili ważne, ale duża część programowania polega nie tylko na mówieniu komputerowi co ma zrobić, ale też na posiadaniu wiedzy jak dokładnie powiedzieć komputerowi żeby to zrobił.

\subsection{Wyrażenia wewnątrz innych wyrażeń}

% Różni się od oryginału - krótsze zdania.
Wyrażenia mogą również zawierać inne wyrażenia. Na przykład, wyrażenie 2+5+8 zawiera dwa operatory +, co powoduje że składa się z~dwóch mniejszych wyrażeń.~Python najpierw oblicza 2+5, wynikiem jest 7. Następnie oblicza 7+8 i~wynikiem jest 15.

% TODO: przykład jest idiotyczny
Pomyśl o~wyrażeniu jak o~stosie cukierków: jeśli położysz dwa stosy cukierków jeden na drugim, będziesz miał znów stos cukierków (tyle, że większy). Duży stos cukierków może być złożony z~mniejszych stosów wysypanych jeden na drugi. Wyrażenia mogą być składane razem i~w~ten sam sposób tworzyć większe wyrażenia. Ale niezależnie od tego jak duże jest wyrażenie, zawsze będzie się ewaluowało do pojedynczej odpowiedzi, podobnie jak 2+5+8 ewaluuje się do 15.

\section{Przechowywanie wartości w~zmiennych}

Kiedy piszemy program, często chcielibyśmy zachować wyniki ewaluacji naszych wyrażeń żeby móc ich używać w~dalszej części programu. Możemy przechowywać wartości w~{\bf zmiennych}.

Pomyśl że zmienna to pudełko które może przechowywać wartość. Możesz przechować wartość w~zmiennej używając znaku = (nazywanego {\bf operatorem przypisania}). na przykład, żeby przechować wartość 15 w~zmiennej o~nazwie ,,liczba'', wpisz w~shellu liczba=15:

\lstset{language=python}
\begin{lstlisting}{}
>>> liczba = 15
>>>
\end{lstlisting}

\img{idle-zmienna}{Zmienne są jak pudełka które przechowują wartości}{4cm}

Zmienna którą stworzyłeś jest jak pudełko z~wartością 15 w~środku (jak na rysunku \ref{idle-zmienna}). Nazwa zmiennej (,,liczba'') jest jak etykieta na pudełku (żeby można było rozróżnić jedną zmienną od drugiej), a~wartość przechowywana przez zmienną jest jak karteczka w~środku pudełka.

Kiewy wciśniesz Enter, nie zobaczysz żadnej odpowiedzi od Pythona. O~ile nie zobaczysz wiadomości o~błędzie, możesz założyć że instrukcja została wykonana poprawnie. Pojawi się następny znak zachęty >>> żebyś mógł wpisać kolejną instrukcję.

Ta instrukcja (nazywana {\bf instrukcją przypisania}) tworzy zmienną ,,liczba'' i~przechowuje w~niej wartość 15. W~przeciwieństwie do wyrażeń, {\bf instrukcje} nie są ewaluowane do żadnej wartości. Dlatego właśnie shell nie wyświetlił żadnej wartości w~odpowiedzi.

Może nie być łatwo zapamiętać które polecenia są wyrażeniami a~które instrukcjami. Po prostu pamiętaj że jeśli polecenie ewaluuje się do jakiejś wartości, jest wyrażeniem. Jeśli nie, jest instrukcją.

Instrukcja przypisania jest zapisana w następujący sposób: nazwa zmiennej, później znak = oraz wyrażenie. Wartość do której ewaluuje się to wyrażenie jest przechowywana w~zmiennej. Wartość 15 sama w~sobie jest wyrażeniem. Wyrażenia złożone z~pojedynczej wartości są proste do ewaluacji. Takie wyrażenia ewaluują się po prostu do tej samej wartości. Na przykład, wyrażenie 15 ewaluuje się do wartości 15.

Pemiętaj, zmienne przechowują wartości, nie wyrażenia. Na przykład, jeśli mielibyśmy wyrażenie liczba=10+5, to wyrażenie 10+5 zostałoby wpierw obliczone, a~następnie wynik (15) zostałby przechowany w~zmiennej ,,liczba''.

Kiedy zapisujesz wartość do zmiennej po raz pierwszy używając instrukcji przypisania, Python stworzy tą zmienną. Za każdym następnym razem, operator przypisania zamieni wartość zapamiętaną w tej zmiennej.

Sprawdźmy czy zmienna stworzyła się poprawnie. Jeśli wpiszemy w shellu tylko "liczba", powinniśmy zobaczyć jaka wartość jest przechowywana w zmiennej o tej nazwie:

\begin{lstlisting}
>>> liczba = 15
>>> liczba
15
>>> 
\end{lstlisting}

W tej chwili wyrażenie "liczba" jest ewaluowane do wartości przechowywaną przez zmienną "liczba", czyli 15.

Wiedząc to wszystko, możemy zrobić ciekawą rzecz. Jeśli teraz wpiszemy do shella "liczba + 5", otrzymamy wartość 20:

\begin{lstlisting}
>>> liczba+5
20
>>> 
\end{lstlisting}

Może się to wydawać dziwne, ale ma sens jeśli przypomnimy sobie że ustawiliśmy wartość "liczba" na 15. Z tego powodu, napisanie "liczba + 5" jest zupełnie jak napisanie "15 + 5".

Jeśli spróbujesz użyć zmiennej zanim została stworzona, Python zwróci ci komunikat błędu ponieważ taka zmienna jeszcze nie istnieje. Zdarzy się to również jeśli zrobisz literówkę w nazwie istniejącej zmiennej:


\begin{lstlisting}
>>> lcibza

Traceback (most recent call last):
  File "<pyshell#10>", line 1, in <module>
      lcibza
NameError: name 'lcibza' is not defined
>>> 
\end{lstlisting}

Możemy zmienić wartość przechowywaną w zmiennej wprowadzając jeszcze jedną instrukcję przypisania. Spróbuj na przykład tego:

\begin{lstlisting}
>>> liczba=15
>>> liczba + 5
20
>>> liczba = 3
>>> liczba + 5
8
>>> 
\end{lstlisting}

Za pierwszym razem kiedy wpisałeś "liczba + 5", wartością wyrażenia było 20, ponieważ zmienna "liczba" przechowywała wartość 15. Ale kiedy wpisałeś "liczba = 3", wartość 15 została zamieniona (nadpisana) wartością 3. Z tego powodu, jeśli wpisałeś później "liczba + 5", wartością wyrażenia było 8.

Aby dowiedzieć się jaką wartość przechowuje zmienna, wpisz jej nazwę w shellu.

Ponieważ zmienna jest tylko nazwą dla wartości, możemy robić też takie działania jak poniżej:

\begin{lstlisting}
>>> liczba = 15
>>> liczba + liczba
30
>>> liczba - liczba
0
>>> 
\end{lstlisting}

Kiedy zmienna "liczba" przechowuje wartość 15, wpisanie "liczba + liczba" odpowiada wpisaniu "15 + 15". Wartością takiego wyrażenia jest 30. Z kolei wyrażenie "liczba - liczba" ma wartość 0 ponieważ odpowiada wyrażeniu "15 - 15". Wyrażenia powyżej używają zmiennej "liczba" dwa razy. Możesz używać zmiennych w wyrażeniach ile tylko razy chcesz. Pamiętaj że Python będzie ewaluował nazwę zmiennej do wartości w niej przechowywanej za każdym razem kiedy zmienna będzie użyta.

Możemy nawet użyć wartości zmiennej "liczba" aby przypisać zmiennej "liczba" nową wartość!

\begin{lstlisting}
>>> liczba = 15
>>> liczba = liczba + 5
>>> liczba
20
\end{lstlisting}

Wyrażenie przypisania "liczba = liczba + 5" jest jak powiedzenie "nowa wartość zmiennej liczba będzie równa obecnej wartości plus pięć". Pamiętaj że do zmiennej po lewej stronie znaku = będzie przypisana wartość do której ewaluuje się wyrażenie po prawej stronie znaku. Możemy też zwiększać wartość zmiennej liczba kilka razy:

\begin{lstlisting}
>>> liczba = 15
>>> liczba = liczba + 5
>>> liczba = liczba + 5
>>> liczba = liczba + 5
>>> liczba
30
\end{lstlisting}

\section{Używanie więcej niż jednej zmiennej}

Kiedy piszesz program, nie jesteś ograniczony do używania jednej zmiennej. Często będziesz potrzebował używać wielu zmiennych.

Na przykład, przypiszmy różne wartości do dwóch zmiennych o nazwach "foo" oraz "bar":

\begin{lstlisting}
>>> foo = 10
>>> bar = 15
\end{lstlisting}

Teraz zmienna foo ma wartość 10, a zmienna bar - 15.

\img{idle-zmienne}{Zmienne "foo" i "bar" przechowują różne wartości}{10cm}

Spróbujmy zmienić teraz zmienną "liczba". Wpisz "liczba = foo + bar" do okna shella i sprawdź jaka będzie nowa wartość zmiennej "liczba". Czy potrafisz zgadnąć jaka?

\begin{lstlisting}
>>> foo = 10
>>> bar = 15
>>> liczba = foo + bar
>>> liczba
25
\end{lstlisting}

Wartość zmiennej "liczba" wynosi teraz 25, ponieważ kiedy dodajemy "foo" i "bar", dodajemy wartości przechowywane w "foo" (10) i "bar" (15).

\subsection{Nadpisywanie zmiennych}

Zmiana wartości przechowywanej w zmiennej jest prosta. Po prostu przypisz jej nową wartość. Sprawdź co się stanie po wprowadzeniu następującego kodu do shella:

\begin{lstlisting}
>>> foo = 42
>>> foo
42
>>> foo = 'Czesc'
>>> foo
'Czesc'
\end{lstlisting}

Na początku, zmienna "foo" przechowywała liczbę 42. Dlatego właśnie za pierwszym razem po wpisaniu "foo" komputer zwrócił "42". Ale po wykonaniu "spam='Czesc'", wartość 42 została usunięta ze zmiennej i zapomniana w momencie kiedy tekst "Czesc" został w niej zapamiętany.

Zmiana wartości zmiennej na nową wartość nazywana jest {\bf nadpisywaniem} jej wartości. Ważne jest żeby wiedzieć, że stara wartość zostanie na zawsze zapomniana. Jeśli chcesz zapamiętać tą wartość żeby użyć jej później, możesz zapamiętać ją w innej zmiennej przed zmianą wartości.

\begin{lstlisting}
>>> foo = 42
>>> foo
42
>>> stareFoo = foo
>>> foo = 'Czesc'
>>> foo
'Czesc'
>>> stareFoo
42
\end{lstlisting}

W powyższym przykładzie, przed nadpisaniem wartości zmiennej "foo", skopiowaliśmy jej wartość do zmiennej o nazwie "stareFoo". W tym momencie, zarówno "foo" jak i "stareFoo" mają wartość 42. W następnej linii, w zmiennej "foo" zapamiętany zostaje tekst "Czesc", ale zmienna stareFoo pozostaje nietknięta.

\section{Podsumowanie}

W tym rozdziale nauczyłeś się podstaw pisania instrukcji Pythona. Musisz mówić Pythonowi bardzo dokładnie i ściśle co ma zrobić ponieważ komputery nie potrafią myśleć i rozumieją tylko bardzo proste rozkazy. Nauczyłeś się że Python potrafi ewaluować wyrażenia (to znaczy, zamienić całe wyrażenie na pojedynczą wartość), i że wyrażenia to wartości (takie jak 2 czy 5) połączone operatorami (takimi jak + lub -). Dowiedziałeś się także, że możesz przechowywać wartości w zmiennych, żeby twój program je zapamiętał a ty użył ich później.

W następnym rozdziale, poznasz trochę więcej podstawowych pojęć, a później napiszesz swój pierwszy program!

\end{document}
